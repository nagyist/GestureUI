<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>GClasses: GClasses::GVec Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_g_classes.html">GClasses</a>::<a class="el" href="class_g_classes_1_1_g_vec.html">GVec</a>
  </div>
</div>
<div class="contents">
<h1>GClasses::GVec Class Reference</h1><!-- doxytag: class="GClasses::GVec" -->Contains some useful functions for operating on vectors.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;GVec.h&gt;</code>
<p>

<p>
<a href="class_g_classes_1_1_g_vec-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#bc125909fcdf11788338ee7b32098e12">test</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs unit tests for this class. Throws an exception if there is a failure.  <a href="#bc125909fcdf11788338ee7b32098e12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a4792f2f3b6350abfe59a4e1868074e2">doesContainUnknowns</a> (const double *pVector, int nSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This returns true if the vector contains any unknown values. Most of the methods in this class will give bad results if a vector contains unknown values, but for efficiency reasons, they don't check. So it's your job to check your vectors first.  <a href="#a4792f2f3b6350abfe59a4e1868074e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#92ae79b761cc1faeb206e0a13dc547a6">copy</a> (double *pDest, const double *pSource, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This just wraps memcpy.  <a href="#92ae79b761cc1faeb206e0a13dc547a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#94a1abb748f69f72f9e06b39f926d343">dotProduct</a> (const double *pA, const double *pB, int nSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the dot product of two vectors. Results are undefined if pA or pB contain unknown values.  <a href="#94a1abb748f69f72f9e06b39f926d343"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#8a9ce119e75d6d199cb18f76bc4a79f0">dotProduct</a> (const double *pOrigin, const double *pTarget, const double *pVector, int nSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the dot product of (pTarget - pOrigin) with pVector.  <a href="#8a9ce119e75d6d199cb18f76bc4a79f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a6c6212a8efc46d562ce2fbe91a01040">dotProduct</a> (const double *pOriginA, const double *pTargetA, const double *pOriginB, const double *pTargetB, int nSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the dot product of (pTargetA - pOriginA) with (pTargetB - pOriginB).  <a href="#a6c6212a8efc46d562ce2fbe91a01040"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#1663915a5d22c9db72294ffd6cf28cc8">dotProductIgnoringUnknowns</a> (const double *pOrigin, const double *pTarget, const double *pVector, int nSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the dot product of (pTarget - pOrigin) with pVector. Unknown values in pTarget will simply be ignored. (pOrigin and pVector must not contain any unknown values.).  <a href="#1663915a5d22c9db72294ffd6cf28cc8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#d522e7517c9ca6b84c6e14693b5579c5">squaredMagnitude</a> (const double *pVector, int nSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the squared magnitude of the vector.  <a href="#d522e7517c9ca6b84c6e14693b5579c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#abde02591e9da942506c931c1d0b8ab4">minkowskiMagnitude</a> (double norm, const double *pVector, int nSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the magnitude in Minkowski distances (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.).  <a href="#abde02591e9da942506c931c1d0b8ab4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#7cb8bdafdfd80ae937c6bb395c98fd60">normalize</a> (double *pVector, int nSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalizes this vector to a magnitude of 1. Throws an exception if the magnitude is zero.  <a href="#7cb8bdafdfd80ae937c6bb395c98fd60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#9d561c5391532e2d4269465f2405f105">safeNormalize</a> (double *pVector, int nSize, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalizes this vector to a magnitude of 1. If the magnitude is zero, it returns a random vector.  <a href="#9d561c5391532e2d4269465f2405f105"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a294a9711b6e3a24453c3b63eb90c02a">sumToOne</a> (double *pVector, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale the vector so that the elements sum to 1.  <a href="#a294a9711b6e3a24453c3b63eb90c02a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#2a79e7ca74d105f05d760225fb1451d4">minkowskiNormalize</a> (double norm, double *pVector, int nSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalizes with Minkowski distances (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.).  <a href="#2a79e7ca74d105f05d760225fb1451d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#615543de6966bc5f1c6eaee5fe13f491">squaredDistance</a> (const double *pA, const double *pB, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the squared distance between two vectors.  <a href="#615543de6966bc5f1c6eaee5fe13f491"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#2f37b715d1f704836396af21bc8ce614">estimateSquaredDistanceWithUnknowns</a> (const double *pA, const double *pB, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimates the squared distance between two points that may have some missing values. It assumes the distance in missing dimensions is approximately the same as the average distance in other dimensions. If there are no known dimensions that overlap between the two points, it returns 1e50.  <a href="#2f37b715d1f704836396af21bc8ce614"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#ec199d91a4d8fe8de05943d0050f3f9b">minkowskiDistance</a> (double norm, const double *pA, const double *pB, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes Minkowski distances (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.).  <a href="#ec199d91a4d8fe8de05943d0050f3f9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#6e21cb45ceb91e957df50a5b3da78488">correlation</a> (const double *pA, const double *pB, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the cosine of the angle between two vectors (the origin is the vertex).  <a href="#6e21cb45ceb91e957df50a5b3da78488"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#fee5c126cfb65c728da9ca61899264d7">correlation</a> (const double *pOriginA, const double *pTargetA, const double *pB, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the cosine of the angle between two vectors (the origin is the vertex).  <a href="#fee5c126cfb65c728da9ca61899264d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#70d584cef3c10671be4fd66655c0ae40">correlation</a> (const double *pOriginA, const double *pTargetA, const double *pOriginB, const double *pTargetB, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the cosine of the angle between two vectors (the origin is the vertex).  <a href="#70d584cef3c10671be4fd66655c0ae40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#f885c490605ba8ddc1cc9080ca425c48">indexOfMin</a> (const double *pVector, int dims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the min value in pVector. If multiple elements have have an equivalent max value, it randomly (uniformly) picks from all the ties.  <a href="#f885c490605ba8ddc1cc9080ca425c48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#b362f363c1dd6f38f5ca297b80e96548">indexOfMax</a> (const double *pVector, int dims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the max value in pVector. If multiple elements have have an equivalent max value, it randomly (uniformly) picks from all the ties.  <a href="#b362f363c1dd6f38f5ca297b80e96548"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#2f8e3e688e5ca8e2f5b1f07ab5c02781">indexOfMaxMagnitude</a> (const double *pVector, int dims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the value with the largest magnitude in pVector. If multiple elements have have an equivalent magnitude, it randomly (uniformly) picks from all the ties.  <a href="#2f8e3e688e5ca8e2f5b1f07ab5c02781"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#c75c295cd7fc9f95d481308384d4d164">add</a> (double *pDest, const double *pSource, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds pSource to pDest.  <a href="#c75c295cd7fc9f95d481308384d4d164"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#167516a03f2013a257a07362d3a7d73d">addScaled</a> (double *pDest, double dMag, const double *pSource, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds dMag * pSource to pDest.  <a href="#167516a03f2013a257a07362d3a7d73d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#2096b3eef202d3d68b245413c3203ca5">addLog</a> (double *pDest, const double *pSource, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the log of each element in pSource to pDest.  <a href="#2096b3eef202d3d68b245413c3203ca5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#9727b0f9f9cfaa1d89ff48dce60d8c2a">subtract</a> (double *pDest, const double *pSource, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtracts pSource from pDest.  <a href="#9727b0f9f9cfaa1d89ff48dce60d8c2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#d4dda22e6b2f081d23c5e338ecb27773">multiply</a> (double *pVector, double dScalar, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies pVector by dScalar.  <a href="#d4dda22e6b2f081d23c5e338ecb27773"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#0808f94c212e4651bd01849bab90a5cd">pairwiseMultiply</a> (double *pDest, double *pOther, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies each element in pDest by the corresponding element in pOther.  <a href="#0808f94c212e4651bd01849bab90a5cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#50b72a2a7edb0ee9352549f0b4776bc0">pairwiseDivide</a> (double *pDest, double *pOther, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divides each element in pDest by the corresponding element in pOther.  <a href="#50b72a2a7edb0ee9352549f0b4776bc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#e089b6a59fd1b88a20b0072a0b02e126">setAll</a> (double *pVector, double value, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets all the elements to the specified value.  <a href="#e089b6a59fd1b88a20b0072a0b02e126"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#8163d8154157c02ae2bda09c9132ffd8">mostEccentricPoints</a> (int *pOutPoints, int nPoints, double *pVector, int nDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the specified number of indexes of the most eccentric points in sorted order, where the most eccentric points are defined as the local-maxes of the local-maxes of the ..., and the local-mins of the local-mins of the ...  <a href="#8163d8154157c02ae2bda09c9132ffd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#33efde2cec43f37ea476d9a5659d16e8">interpolateIndexes</a> (int nIndexes, double *pInIndexes, double *pOutIndexes, float fRatio, int nCorrIndexes, double *pCorrIndexes1, double *pCorrIndexes2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolates (morphs) a set of indexes from one function to another. pInIndexes, pCorrIndexes1, and pCorrIndexes2 are all expected to be in sorted order. All indexes should be &gt;= 0 and &lt; nDims. fRatio is the interpolation ratio such that if fRatio is zero, all indexes left unchanged, and as fRatio approaches one, the indexes are interpolated linearly such that each index in pCorrIndexes1 is interpolated linearly to the corresponding index in pCorrIndexes2. If the two extremes are not in the list of corresponding indexes, the ends may drift.  <a href="#33efde2cec43f37ea476d9a5659d16e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#d569d319dfc8938ae03ac21b2fe12313">rotate</a> (double *pVector, int nDims, double dAngle, const double *pA, const double *pB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotates pVector by dAngle radians in the plane defined by the orthogonal axes pA and pB.  <a href="#d569d319dfc8938ae03ac21b2fe12313"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#72376a33d7b5dbb6e187b3c0027dd5b1">valueIndex</a> (double *pVector, int nDims, double dVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the first element with a value exactly equal to dVal, or -1 if not found.  <a href="#72376a33d7b5dbb6e187b3c0027dd5b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#86e2270af85485a1a3aba27777a2db59">addInterpolatedFunction</a> (double *pOut, int nOutVals, double *pIn, int nInVals)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the function pIn to pOut after interpolating pIn to be the same size as pOut.  <a href="#86e2270af85485a1a3aba27777a2db59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#5fe2a618bea988a704a81cdec223766e">toTwt</a> (<a class="el" href="class_g_classes_1_1_g_twt_doc.html">GTwtDoc</a> *pDoc, const double *pVec, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the vector to a text format.  <a href="#5fe2a618bea988a704a81cdec223766e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#9e663d714a1177212ff5849b45f9b74a">fromTwt</a> (double *pVec, int dims, <a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a> *pNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load the vector from a text format. Throws if it contains an unexpected number of dims.  <a href="#9e663d714a1177212ff5849b45f9b74a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#3ebe7224fa305e1b10df60e72780c0d6">print</a> (std::ostream &amp;stream, int precision, double *pVec, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the values in the vector separated by ", ". precision specifies the number of digits to print.  <a href="#3ebe7224fa305e1b10df60e72780c0d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#6e6a8be4ecad232208e2d08c513db218">project</a> (double *pDest, const double *pPoint, const double *pOrigin, const double *pBasis, int basisCount, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Projects pPoint onto the hyperplane defined by pOrigin onto the basisCount basis vectors specified by pBasis. (The basis vectors are assumed to be chained end-to-end in a big vector.).  <a href="#6e6a8be4ecad232208e2d08c513db218"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#6c1ad41be343741c30a8b56e5985806d">subtractComponent</a> (double *pInOut, const double *pBasis, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtracts the component of pInOut that projects onto pBasis. (Assumes that pBasis is normalized.) This might be used, for example, to implement the modified Gram-Schmidt process.  <a href="#6c1ad41be343741c30a8b56e5985806d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#b8340b3f0eb879809640a9a75180638e">subtractComponent</a> (double *pInOut, const double *pOrigin, const double *pTarget, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtracts the component of pInOut that projects onto (pTarget - pOrigin). This might be used, for example, to implement the modified Gram-Schmidt process.  <a href="#b8340b3f0eb879809640a9a75180638e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#468415af9bf2857ca97376e17411e385">sumElements</a> (const double *pVec, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the sum of all the elements.  <a href="#468415af9bf2857ca97376e17411e385"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#1825bb317966fe9c92bf2d0d7967901d">smallestToFront</a> (double *pVec, int k, int size, double *pParallel1=NULL, size_t *pParallel2=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the smallest k values to the front of the vector, and the biggest (size - k) values to the end of the vector. (For efficiency, no other guarantees about ordering are made.) This has an average-case runtime that is linear with respect to size. pParallel1 and pParallel2 are optional arrays that should be arranged to keep their indices in sync with pVec.  <a href="#1825bb317966fe9c92bf2d0d7967901d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#151c5772d1f18902e3193230bbb5f7c2">refinePoint</a> (double *pPoint, double *pNeighbor, int dims, double distance, double learningRate, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves "pPoint" so that it is closer to a distance of "distance" from "pNeighbor". "learningRate" specifies how much to move it (0=not at all, 1=all the way). Returns the squared distance between pPoint and pNeighbor.  <a href="#151c5772d1f18902e3193230bbb5f7c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#ca682fa0c2b918c2e96dd6dc643ee8e3">toImage</a> (const double *pVec, <a class="el" href="class_g_classes_1_1_g_image.html">GImage</a> *pImage, int width, int height, int channels, double range)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a vector of rasterized pixel values to an image. channels must be 1 or 3 (for grayscale or rgb) range specifies the range of channel values. Typical values are 1.0 or 255.0. Pixels are visited in reading order (left-to-right, top-to-bottom).  <a href="#ca682fa0c2b918c2e96dd6dc643ee8e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#9ece0334bb8cc2b3982b3fe76d79ab6c">fromImage</a> (<a class="el" href="class_g_classes_1_1_g_image.html">GImage</a> *pImage, double *pVec, int width, int height, int channels, double range)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an image to a vector of rasterized pixel values. channels must be 1 or 3 (for grayscale or rgb) range specifies the range of channel values. Typical values are 1.0 or 255.0. Pixels are visited in reading order (left-to-right, top-to-bottom).  <a href="#9ece0334bb8cc2b3982b3fe76d79ab6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#ff229378115e4442e64d77ffadd44141">capValues</a> (double *pVec, double cap, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets each value, v, to MIN(cap, v).  <a href="#ff229378115e4442e64d77ffadd44141"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a1534fa6f615b158dbf16781904d7525">floorValues</a> (double *pVec, double floor, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets each value, v, to MAX(floor, v).  <a href="#a1534fa6f615b158dbf16781904d7525"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#28f7d69655c5662e774b6429d1bf556c">mostEccentricMaxs</a> (int *pOutPoints, int nPoints, bool bMax, double *pVector, int nDims)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Contains some useful functions for operating on vectors. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c75c295cd7fc9f95d481308384d4d164"></a><!-- doxytag: member="GClasses::GVec::add" ref="c75c295cd7fc9f95d481308384d4d164" args="(double *pDest, const double *pSource, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::add           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds pSource to pDest. 
<p>

</div>
</div><p>
<a class="anchor" name="86e2270af85485a1a3aba27777a2db59"></a><!-- doxytag: member="GClasses::GVec::addInterpolatedFunction" ref="86e2270af85485a1a3aba27777a2db59" args="(double *pOut, int nOutVals, double *pIn, int nInVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::addInterpolatedFunction           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nOutVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nInVals</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the function pIn to pOut after interpolating pIn to be the same size as pOut. 
<p>

</div>
</div><p>
<a class="anchor" name="2096b3eef202d3d68b245413c3203ca5"></a><!-- doxytag: member="GClasses::GVec::addLog" ref="2096b3eef202d3d68b245413c3203ca5" args="(double *pDest, const double *pSource, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::addLog           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the log of each element in pSource to pDest. 
<p>

</div>
</div><p>
<a class="anchor" name="167516a03f2013a257a07362d3a7d73d"></a><!-- doxytag: member="GClasses::GVec::addScaled" ref="167516a03f2013a257a07362d3a7d73d" args="(double *pDest, double dMag, const double *pSource, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::addScaled           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dMag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds dMag * pSource to pDest. 
<p>

</div>
</div><p>
<a class="anchor" name="ff229378115e4442e64d77ffadd44141"></a><!-- doxytag: member="GClasses::GVec::capValues" ref="ff229378115e4442e64d77ffadd44141" args="(double *pVec, double cap, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::capValues           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets each value, v, to MIN(cap, v). 
<p>

</div>
</div><p>
<a class="anchor" name="92ae79b761cc1faeb206e0a13dc547a6"></a><!-- doxytag: member="GClasses::GVec::copy" ref="92ae79b761cc1faeb206e0a13dc547a6" args="(double *pDest, const double *pSource, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::copy           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This just wraps memcpy. 
<p>

</div>
</div><p>
<a class="anchor" name="70d584cef3c10671be4fd66655c0ae40"></a><!-- doxytag: member="GClasses::GVec::correlation" ref="70d584cef3c10671be4fd66655c0ae40" args="(const double *pOriginA, const double *pTargetA, const double *pOriginB, const double *pTargetB, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::correlation           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pOriginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pTargetA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pOriginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pTargetB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the cosine of the angle between two vectors (the origin is the vertex). 
<p>

</div>
</div><p>
<a class="anchor" name="fee5c126cfb65c728da9ca61899264d7"></a><!-- doxytag: member="GClasses::GVec::correlation" ref="fee5c126cfb65c728da9ca61899264d7" args="(const double *pOriginA, const double *pTargetA, const double *pB, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::correlation           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pOriginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pTargetA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the cosine of the angle between two vectors (the origin is the vertex). 
<p>

</div>
</div><p>
<a class="anchor" name="6e21cb45ceb91e957df50a5b3da78488"></a><!-- doxytag: member="GClasses::GVec::correlation" ref="6e21cb45ceb91e957df50a5b3da78488" args="(const double *pA, const double *pB, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::correlation           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the cosine of the angle between two vectors (the origin is the vertex). 
<p>

</div>
</div><p>
<a class="anchor" name="a4792f2f3b6350abfe59a4e1868074e2"></a><!-- doxytag: member="GClasses::GVec::doesContainUnknowns" ref="a4792f2f3b6350abfe59a4e1868074e2" args="(const double *pVector, int nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool GClasses::GVec::doesContainUnknowns           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This returns true if the vector contains any unknown values. Most of the methods in this class will give bad results if a vector contains unknown values, but for efficiency reasons, they don't check. So it's your job to check your vectors first. 
<p>

</div>
</div><p>
<a class="anchor" name="a6c6212a8efc46d562ce2fbe91a01040"></a><!-- doxytag: member="GClasses::GVec::dotProduct" ref="a6c6212a8efc46d562ce2fbe91a01040" args="(const double *pOriginA, const double *pTargetA, const double *pOriginB, const double *pTargetB, int nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::dotProduct           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pOriginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pTargetA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pOriginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pTargetB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the dot product of (pTargetA - pOriginA) with (pTargetB - pOriginB). 
<p>

</div>
</div><p>
<a class="anchor" name="8a9ce119e75d6d199cb18f76bc4a79f0"></a><!-- doxytag: member="GClasses::GVec::dotProduct" ref="8a9ce119e75d6d199cb18f76bc4a79f0" args="(const double *pOrigin, const double *pTarget, const double *pVector, int nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::dotProduct           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the dot product of (pTarget - pOrigin) with pVector. 
<p>

</div>
</div><p>
<a class="anchor" name="94a1abb748f69f72f9e06b39f926d343"></a><!-- doxytag: member="GClasses::GVec::dotProduct" ref="94a1abb748f69f72f9e06b39f926d343" args="(const double *pA, const double *pB, int nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::dotProduct           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the dot product of two vectors. Results are undefined if pA or pB contain unknown values. 
<p>

</div>
</div><p>
<a class="anchor" name="1663915a5d22c9db72294ffd6cf28cc8"></a><!-- doxytag: member="GClasses::GVec::dotProductIgnoringUnknowns" ref="1663915a5d22c9db72294ffd6cf28cc8" args="(const double *pOrigin, const double *pTarget, const double *pVector, int nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::dotProductIgnoringUnknowns           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the dot product of (pTarget - pOrigin) with pVector. Unknown values in pTarget will simply be ignored. (pOrigin and pVector must not contain any unknown values.). 
<p>

</div>
</div><p>
<a class="anchor" name="2f37b715d1f704836396af21bc8ce614"></a><!-- doxytag: member="GClasses::GVec::estimateSquaredDistanceWithUnknowns" ref="2f37b715d1f704836396af21bc8ce614" args="(const double *pA, const double *pB, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::estimateSquaredDistanceWithUnknowns           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Estimates the squared distance between two points that may have some missing values. It assumes the distance in missing dimensions is approximately the same as the average distance in other dimensions. If there are no known dimensions that overlap between the two points, it returns 1e50. 
<p>

</div>
</div><p>
<a class="anchor" name="a1534fa6f615b158dbf16781904d7525"></a><!-- doxytag: member="GClasses::GVec::floorValues" ref="a1534fa6f615b158dbf16781904d7525" args="(double *pVec, double floor, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::floorValues           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>floor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets each value, v, to MAX(floor, v). 
<p>

</div>
</div><p>
<a class="anchor" name="9ece0334bb8cc2b3982b3fe76d79ab6c"></a><!-- doxytag: member="GClasses::GVec::fromImage" ref="9ece0334bb8cc2b3982b3fe76d79ab6c" args="(GImage *pImage, double *pVec, int width, int height, int channels, double range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::fromImage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_image.html">GImage</a> *&nbsp;</td>
          <td class="paramname"> <em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts an image to a vector of rasterized pixel values. channels must be 1 or 3 (for grayscale or rgb) range specifies the range of channel values. Typical values are 1.0 or 255.0. Pixels are visited in reading order (left-to-right, top-to-bottom). 
<p>

</div>
</div><p>
<a class="anchor" name="9e663d714a1177212ff5849b45f9b74a"></a><!-- doxytag: member="GClasses::GVec::fromTwt" ref="9e663d714a1177212ff5849b45f9b74a" args="(double *pVec, int dims, GTwtNode *pNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::fromTwt           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a> *&nbsp;</td>
          <td class="paramname"> <em>pNode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load the vector from a text format. Throws if it contains an unexpected number of dims. 
<p>

</div>
</div><p>
<a class="anchor" name="b362f363c1dd6f38f5ca297b80e96548"></a><!-- doxytag: member="GClasses::GVec::indexOfMax" ref="b362f363c1dd6f38f5ca297b80e96548" args="(const double *pVector, int dims, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int GClasses::GVec::indexOfMax           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the max value in pVector. If multiple elements have have an equivalent max value, it randomly (uniformly) picks from all the ties. 
<p>

</div>
</div><p>
<a class="anchor" name="2f8e3e688e5ca8e2f5b1f07ab5c02781"></a><!-- doxytag: member="GClasses::GVec::indexOfMaxMagnitude" ref="2f8e3e688e5ca8e2f5b1f07ab5c02781" args="(const double *pVector, int dims, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int GClasses::GVec::indexOfMaxMagnitude           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the value with the largest magnitude in pVector. If multiple elements have have an equivalent magnitude, it randomly (uniformly) picks from all the ties. 
<p>

</div>
</div><p>
<a class="anchor" name="f885c490605ba8ddc1cc9080ca425c48"></a><!-- doxytag: member="GClasses::GVec::indexOfMin" ref="f885c490605ba8ddc1cc9080ca425c48" args="(const double *pVector, int dims, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int GClasses::GVec::indexOfMin           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the min value in pVector. If multiple elements have have an equivalent max value, it randomly (uniformly) picks from all the ties. 
<p>

</div>
</div><p>
<a class="anchor" name="33efde2cec43f37ea476d9a5659d16e8"></a><!-- doxytag: member="GClasses::GVec::interpolateIndexes" ref="33efde2cec43f37ea476d9a5659d16e8" args="(int nIndexes, double *pInIndexes, double *pOutIndexes, float fRatio, int nCorrIndexes, double *pCorrIndexes1, double *pCorrIndexes2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::interpolateIndexes           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pInIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>fRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nCorrIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pCorrIndexes1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pCorrIndexes2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolates (morphs) a set of indexes from one function to another. pInIndexes, pCorrIndexes1, and pCorrIndexes2 are all expected to be in sorted order. All indexes should be &gt;= 0 and &lt; nDims. fRatio is the interpolation ratio such that if fRatio is zero, all indexes left unchanged, and as fRatio approaches one, the indexes are interpolated linearly such that each index in pCorrIndexes1 is interpolated linearly to the corresponding index in pCorrIndexes2. If the two extremes are not in the list of corresponding indexes, the ends may drift. 
<p>

</div>
</div><p>
<a class="anchor" name="ec199d91a4d8fe8de05943d0050f3f9b"></a><!-- doxytag: member="GClasses::GVec::minkowskiDistance" ref="ec199d91a4d8fe8de05943d0050f3f9b" args="(double norm, const double *pA, const double *pB, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::minkowskiDistance           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes Minkowski distances (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.). 
<p>

</div>
</div><p>
<a class="anchor" name="abde02591e9da942506c931c1d0b8ab4"></a><!-- doxytag: member="GClasses::GVec::minkowskiMagnitude" ref="abde02591e9da942506c931c1d0b8ab4" args="(double norm, const double *pVector, int nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::minkowskiMagnitude           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the magnitude in Minkowski distances (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.). 
<p>

</div>
</div><p>
<a class="anchor" name="2a79e7ca74d105f05d760225fb1451d4"></a><!-- doxytag: member="GClasses::GVec::minkowskiNormalize" ref="2a79e7ca74d105f05d760225fb1451d4" args="(double norm, double *pVector, int nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::minkowskiNormalize           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalizes with Minkowski distances (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.). 
<p>

</div>
</div><p>
<a class="anchor" name="28f7d69655c5662e774b6429d1bf556c"></a><!-- doxytag: member="GClasses::GVec::mostEccentricMaxs" ref="28f7d69655c5662e774b6429d1bf556c" args="(int *pOutPoints, int nPoints, bool bMax, double *pVector, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::mostEccentricMaxs           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pOutPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8163d8154157c02ae2bda09c9132ffd8"></a><!-- doxytag: member="GClasses::GVec::mostEccentricPoints" ref="8163d8154157c02ae2bda09c9132ffd8" args="(int *pOutPoints, int nPoints, double *pVector, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::mostEccentricPoints           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pOutPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the specified number of indexes of the most eccentric points in sorted order, where the most eccentric points are defined as the local-maxes of the local-maxes of the ..., and the local-mins of the local-mins of the ... 
<p>

</div>
</div><p>
<a class="anchor" name="d4dda22e6b2f081d23c5e338ecb27773"></a><!-- doxytag: member="GClasses::GVec::multiply" ref="d4dda22e6b2f081d23c5e338ecb27773" args="(double *pVector, double dScalar, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::multiply           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dScalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplies pVector by dScalar. 
<p>

</div>
</div><p>
<a class="anchor" name="7cb8bdafdfd80ae937c6bb395c98fd60"></a><!-- doxytag: member="GClasses::GVec::normalize" ref="7cb8bdafdfd80ae937c6bb395c98fd60" args="(double *pVector, int nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::normalize           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalizes this vector to a magnitude of 1. Throws an exception if the magnitude is zero. 
<p>

</div>
</div><p>
<a class="anchor" name="50b72a2a7edb0ee9352549f0b4776bc0"></a><!-- doxytag: member="GClasses::GVec::pairwiseDivide" ref="50b72a2a7edb0ee9352549f0b4776bc0" args="(double *pDest, double *pOther, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::pairwiseDivide           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOther</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Divides each element in pDest by the corresponding element in pOther. 
<p>

</div>
</div><p>
<a class="anchor" name="0808f94c212e4651bd01849bab90a5cd"></a><!-- doxytag: member="GClasses::GVec::pairwiseMultiply" ref="0808f94c212e4651bd01849bab90a5cd" args="(double *pDest, double *pOther, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::pairwiseMultiply           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOther</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplies each element in pDest by the corresponding element in pOther. 
<p>

</div>
</div><p>
<a class="anchor" name="3ebe7224fa305e1b10df60e72780c0d6"></a><!-- doxytag: member="GClasses::GVec::print" ref="3ebe7224fa305e1b10df60e72780c0d6" args="(std::ostream &amp;stream, int precision, double *pVec, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::print           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the values in the vector separated by ", ". precision specifies the number of digits to print. 
<p>

</div>
</div><p>
<a class="anchor" name="6e6a8be4ecad232208e2d08c513db218"></a><!-- doxytag: member="GClasses::GVec::project" ref="6e6a8be4ecad232208e2d08c513db218" args="(double *pDest, const double *pPoint, const double *pOrigin, const double *pBasis, int basisCount, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::project           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>basisCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Projects pPoint onto the hyperplane defined by pOrigin onto the basisCount basis vectors specified by pBasis. (The basis vectors are assumed to be chained end-to-end in a big vector.). 
<p>

</div>
</div><p>
<a class="anchor" name="151c5772d1f18902e3193230bbb5f7c2"></a><!-- doxytag: member="GClasses::GVec::refinePoint" ref="151c5772d1f18902e3193230bbb5f7c2" args="(double *pPoint, double *pNeighbor, int dims, double distance, double learningRate, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::refinePoint           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pNeighbor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>learningRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves "pPoint" so that it is closer to a distance of "distance" from "pNeighbor". "learningRate" specifies how much to move it (0=not at all, 1=all the way). Returns the squared distance between pPoint and pNeighbor. 
<p>

</div>
</div><p>
<a class="anchor" name="d569d319dfc8938ae03ac21b2fe12313"></a><!-- doxytag: member="GClasses::GVec::rotate" ref="d569d319dfc8938ae03ac21b2fe12313" args="(double *pVector, int nDims, double dAngle, const double *pA, const double *pB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::rotate           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotates pVector by dAngle radians in the plane defined by the orthogonal axes pA and pB. 
<p>

</div>
</div><p>
<a class="anchor" name="9d561c5391532e2d4269465f2405f105"></a><!-- doxytag: member="GClasses::GVec::safeNormalize" ref="9d561c5391532e2d4269465f2405f105" args="(double *pVector, int nSize, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::safeNormalize           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalizes this vector to a magnitude of 1. If the magnitude is zero, it returns a random vector. 
<p>

</div>
</div><p>
<a class="anchor" name="e089b6a59fd1b88a20b0072a0b02e126"></a><!-- doxytag: member="GClasses::GVec::setAll" ref="e089b6a59fd1b88a20b0072a0b02e126" args="(double *pVector, double value, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::setAll           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets all the elements to the specified value. 
<p>

</div>
</div><p>
<a class="anchor" name="1825bb317966fe9c92bf2d0d7967901d"></a><!-- doxytag: member="GClasses::GVec::smallestToFront" ref="1825bb317966fe9c92bf2d0d7967901d" args="(double *pVec, int k, int size, double *pParallel1=NULL, size_t *pParallel2=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::smallestToFront           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pParallel1</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>pParallel2</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the smallest k values to the front of the vector, and the biggest (size - k) values to the end of the vector. (For efficiency, no other guarantees about ordering are made.) This has an average-case runtime that is linear with respect to size. pParallel1 and pParallel2 are optional arrays that should be arranged to keep their indices in sync with pVec. 
<p>

</div>
</div><p>
<a class="anchor" name="615543de6966bc5f1c6eaee5fe13f491"></a><!-- doxytag: member="GClasses::GVec::squaredDistance" ref="615543de6966bc5f1c6eaee5fe13f491" args="(const double *pA, const double *pB, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::squaredDistance           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the squared distance between two vectors. 
<p>

</div>
</div><p>
<a class="anchor" name="d522e7517c9ca6b84c6e14693b5579c5"></a><!-- doxytag: member="GClasses::GVec::squaredMagnitude" ref="d522e7517c9ca6b84c6e14693b5579c5" args="(const double *pVector, int nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::squaredMagnitude           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the squared magnitude of the vector. 
<p>

</div>
</div><p>
<a class="anchor" name="9727b0f9f9cfaa1d89ff48dce60d8c2a"></a><!-- doxytag: member="GClasses::GVec::subtract" ref="9727b0f9f9cfaa1d89ff48dce60d8c2a" args="(double *pDest, const double *pSource, int nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::subtract           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subtracts pSource from pDest. 
<p>

</div>
</div><p>
<a class="anchor" name="b8340b3f0eb879809640a9a75180638e"></a><!-- doxytag: member="GClasses::GVec::subtractComponent" ref="b8340b3f0eb879809640a9a75180638e" args="(double *pInOut, const double *pOrigin, const double *pTarget, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::subtractComponent           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pInOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subtracts the component of pInOut that projects onto (pTarget - pOrigin). This might be used, for example, to implement the modified Gram-Schmidt process. 
<p>

</div>
</div><p>
<a class="anchor" name="6c1ad41be343741c30a8b56e5985806d"></a><!-- doxytag: member="GClasses::GVec::subtractComponent" ref="6c1ad41be343741c30a8b56e5985806d" args="(double *pInOut, const double *pBasis, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::subtractComponent           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pInOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subtracts the component of pInOut that projects onto pBasis. (Assumes that pBasis is normalized.) This might be used, for example, to implement the modified Gram-Schmidt process. 
<p>

</div>
</div><p>
<a class="anchor" name="468415af9bf2857ca97376e17411e385"></a><!-- doxytag: member="GClasses::GVec::sumElements" ref="468415af9bf2857ca97376e17411e385" args="(const double *pVec, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::sumElements           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the sum of all the elements. 
<p>

</div>
</div><p>
<a class="anchor" name="a294a9711b6e3a24453c3b63eb90c02a"></a><!-- doxytag: member="GClasses::GVec::sumToOne" ref="a294a9711b6e3a24453c3b63eb90c02a" args="(double *pVector, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::sumToOne           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scale the vector so that the elements sum to 1. 
<p>

</div>
</div><p>
<a class="anchor" name="bc125909fcdf11788338ee7b32098e12"></a><!-- doxytag: member="GClasses::GVec::test" ref="bc125909fcdf11788338ee7b32098e12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::test           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs unit tests for this class. Throws an exception if there is a failure. 
<p>

</div>
</div><p>
<a class="anchor" name="ca682fa0c2b918c2e96dd6dc643ee8e3"></a><!-- doxytag: member="GClasses::GVec::toImage" ref="ca682fa0c2b918c2e96dd6dc643ee8e3" args="(const double *pVec, GImage *pImage, int width, int height, int channels, double range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::toImage           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_image.html">GImage</a> *&nbsp;</td>
          <td class="paramname"> <em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a vector of rasterized pixel values to an image. channels must be 1 or 3 (for grayscale or rgb) range specifies the range of channel values. Typical values are 1.0 or 255.0. Pixels are visited in reading order (left-to-right, top-to-bottom). 
<p>

</div>
</div><p>
<a class="anchor" name="5fe2a618bea988a704a81cdec223766e"></a><!-- doxytag: member="GClasses::GVec::toTwt" ref="5fe2a618bea988a704a81cdec223766e" args="(GTwtDoc *pDoc, const double *pVec, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a>* GClasses::GVec::toTwt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_twt_doc.html">GTwtDoc</a> *&nbsp;</td>
          <td class="paramname"> <em>pDoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the vector to a text format. 
<p>

</div>
</div><p>
<a class="anchor" name="72376a33d7b5dbb6e187b3c0027dd5b1"></a><!-- doxytag: member="GClasses::GVec::valueIndex" ref="72376a33d7b5dbb6e187b3c0027dd5b1" args="(double *pVector, int nDims, double dVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int GClasses::GVec::valueIndex           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dVal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the first element with a value exactly equal to dVal, or -1 if not found. 
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Nov 2 14:18:25 2010 for GClasses by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
