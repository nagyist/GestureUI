<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>GClasses: GClasses::GTransducer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_g_classes.html">GClasses</a>::<a class="el" href="class_g_classes_1_1_g_transducer.html">GTransducer</a>
  </div>
</div>
<div class="contents">
<h1>GClasses::GTransducer Class Reference</h1><!-- doxytag: class="GClasses::GTransducer" -->This is the base class of supervised learning algorithms (that may or may not have an internal model allowing them to generalize rows that were not available at training time). Note that the literature typically refers to supervised learning algorithms that can't generalize (because they lack an internal hypothesis model) as "Semi-supervised". (You cannot generalize with a semi-supervised algorithm--you have to train again with the new rows.).  
<a href="#_details">More...</a>
<p>
<code>#include &lt;GLearner.h&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for GClasses::GTransducer:</div>
<div class="dynsection">

<p><center><img src="class_g_classes_1_1_g_transducer.png" usemap="#GClasses::GTransducer_map" border="0" alt=""></center>
<map name="GClasses::GTransducer_map">
<area href="class_g_classes_1_1_g_agglomerative_transducer.html" alt="GClasses::GAgglomerativeTransducer" shape="rect" coords="0,56,226,80">
<area href="class_g_classes_1_1_g_graph_cut_transducer.html" alt="GClasses::GGraphCutTransducer" shape="rect" coords="236,56,462,80">
<area href="class_g_classes_1_1_g_neighbor_transducer.html" alt="GClasses::GNeighborTransducer" shape="rect" coords="472,56,698,80">
<area href="class_g_classes_1_1_g_supervised_learner.html" alt="GClasses::GSupervisedLearner" shape="rect" coords="708,56,934,80">
<area href="class_g_classes_1_1_g_bag.html" alt="GClasses::GBag" shape="rect" coords="944,112,1170,136">
<area href="class_g_classes_1_1_g_baseline_learner.html" alt="GClasses::GBaselineLearner" shape="rect" coords="944,168,1170,192">
<area href="class_g_classes_1_1_g_bucket.html" alt="GClasses::GBucket" shape="rect" coords="944,224,1170,248">
<area href="class_g_classes_1_1_g_decision_tree.html" alt="GClasses::GDecisionTree" shape="rect" coords="944,280,1170,304">
<area href="class_g_classes_1_1_g_identity_function.html" alt="GClasses::GIdentityFunction" shape="rect" coords="944,336,1170,360">
<area href="class_g_classes_1_1_g_incremental_learner.html" alt="GClasses::GIncrementalLearner" shape="rect" coords="944,392,1170,416">
<area href="class_g_classes_1_1_g_kernel_machine.html" alt="GClasses::GKernelMachine" shape="rect" coords="944,448,1170,472">
<area href="class_g_classes_1_1_g_linear_regressor.html" alt="GClasses::GLinearRegressor" shape="rect" coords="944,504,1170,528">
<area href="class_g_classes_1_1_g_mean_margins_tree.html" alt="GClasses::GMeanMarginsTree" shape="rect" coords="944,560,1170,584">
<area href="class_g_classes_1_1_g_naive_m_l_e.html" alt="GClasses::GNaiveMLE" shape="rect" coords="944,616,1170,640">
<area href="class_g_classes_1_1_g_polynomial.html" alt="GClasses::GPolynomial" shape="rect" coords="944,672,1170,696">
</map>
</div>

<p>
<a href="class_g_classes_1_1_g_transducer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#75327ad2cbbaa482f72c5794b7950759">GTransducer</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#702278d6f5cb337f7183e798350e548f">GTransducer</a> (<a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a> *pLearner)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#e77843e6a0cdbc0fa8c840e64b3efefa">~GTransducer</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#35df6d2e140eb0d8625dd30be6b2fbcd">canGeneralize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns false because semi-supervised learners have no internal model, so they can't evaluate previously unseen rows.  <a href="#35df6d2e140eb0d8625dd30be6b2fbcd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a57bff4886e0fd85f946e8f627798a0b">canTrainIncrementally</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns false because semi-supervised learners cannot be trained incrementally.  <a href="#a57bff4886e0fd85f946e8f627798a0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a0f11b6006bee48f545335a3a028dd25">transduce</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pDataLabeled, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pDataUnlabeled, int labelDims)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trains with pDataLabeled, and then predicts labels for all the rows in pDataUnlabeled. (Works with model-free algorithms that cannot be trained.) The rows in pDataUnlabeled are expected to have space allocated for labels, but the values will be overwritten with the predicted values.  <a href="#a0f11b6006bee48f545335a3a028dd25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a323b06012fe8974233026d441253408">trainAndTest</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pTrainingSet, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pTestSet, int labelDims, double *pOutResults)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trains and tests this learner. pOutResults should have an element for each label dim.  <a href="#a323b06012fe8974233026d441253408"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#7036305f9314fb60778596fa7f19c34d">crossValidate</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pData, int nFolds, int labelDims, <a class="el" href="namespace_g_classes.html#4e2f99ff8c7fd6755d3d32a025500b3b">RepValidateCallback</a> pCB=NULL, int nRep=0, void *pThis=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform n-fold cross validation on pData. Uses trainAndTest for each fold. pCB is an optional callback method for reporting intermediate stats. It can be NULL if you don't want intermediate reporting. nRep is just the rep number that will be passed to the callback. pThis is just a pointer that will be passed to the callback for you to use however you want. It doesn't affect this method. The results of each fold is returned in a dataset.  <a href="#7036305f9314fb60778596fa7f19c34d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#606b4211dd74510df18fc6ba539346a3">repValidate</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pData, int nReps, int nFolds, int labelDims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand, <a class="el" href="namespace_g_classes.html#4e2f99ff8c7fd6755d3d32a025500b3b">RepValidateCallback</a> pCB=NULL, void *pThis=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform cross validation "nReps" times and return the average score. (5 reps with 2 folds is preferred over 10-fold cross validation because it yields less type 1 error.) pCB is an optional callback method for reporting intermediate stats It can be NULL if you don't want intermediate reporting. pThis is just a pointer that will be passed to the callback for you to use however you want. It doesn't affect this method. The results of each fold is returned in a dataset.  <a href="#606b4211dd74510df18fc6ba539346a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#c2c140ad19628ad9f527fd748ccc66c7">heuristicValidate</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pData, int labelDims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This performs two-fold cross-validation on a shuffled non-uniform split of the data, and returns an error value that represents the results of all labels combined. (This is for heuristic optimization, not for reporting accuracy.).  <a href="#c2c140ad19628ad9f527fd748ccc66c7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#9dfea5107fb0dc56ea2e6c377fbc1196">baseTwtNode</a> (<a class="el" href="class_g_classes_1_1_g_twt_doc.html">GTwtDoc</a> *pDoc, const char *szClassName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Child classes should use this in their implementation of toTwt.  <a href="#9dfea5107fb0dc56ea2e6c377fbc1196"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This is the base class of supervised learning algorithms (that may or may not have an internal model allowing them to generalize rows that were not available at training time). Note that the literature typically refers to supervised learning algorithms that can't generalize (because they lack an internal hypothesis model) as "Semi-supervised". (You cannot generalize with a semi-supervised algorithm--you have to train again with the new rows.). <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="75327ad2cbbaa482f72c5794b7950759"></a><!-- doxytag: member="GClasses::GTransducer::GTransducer" ref="75327ad2cbbaa482f72c5794b7950759" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GTransducer::GTransducer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="702278d6f5cb337f7183e798350e548f"></a><!-- doxytag: member="GClasses::GTransducer::GTransducer" ref="702278d6f5cb337f7183e798350e548f" args="(GTwtNode *pLearner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GTransducer::GTransducer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a> *&nbsp;</td>
          <td class="paramname"> <em>pLearner</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e77843e6a0cdbc0fa8c840e64b3efefa"></a><!-- doxytag: member="GClasses::GTransducer::~GTransducer" ref="e77843e6a0cdbc0fa8c840e64b3efefa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GClasses::GTransducer::~GTransducer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9dfea5107fb0dc56ea2e6c377fbc1196"></a><!-- doxytag: member="GClasses::GTransducer::baseTwtNode" ref="9dfea5107fb0dc56ea2e6c377fbc1196" args="(GTwtDoc *pDoc, const char *szClassName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a>* GClasses::GTransducer::baseTwtNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_twt_doc.html">GTwtDoc</a> *&nbsp;</td>
          <td class="paramname"> <em>pDoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szClassName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Child classes should use this in their implementation of toTwt. 
<p>

</div>
</div><p>
<a class="anchor" name="35df6d2e140eb0d8625dd30be6b2fbcd"></a><!-- doxytag: member="GClasses::GTransducer::canGeneralize" ref="35df6d2e140eb0d8625dd30be6b2fbcd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GClasses::GTransducer::canGeneralize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns false because semi-supervised learners have no internal model, so they can't evaluate previously unseen rows. 
<p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_supervised_learner.html#b1e4fe0616f81d4df99f71a618c64f75">GClasses::GSupervisedLearner</a>.</p>

</div>
</div><p>
<a class="anchor" name="a57bff4886e0fd85f946e8f627798a0b"></a><!-- doxytag: member="GClasses::GTransducer::canTrainIncrementally" ref="a57bff4886e0fd85f946e8f627798a0b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GClasses::GTransducer::canTrainIncrementally           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns false because semi-supervised learners cannot be trained incrementally. 
<p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_incremental_learner.html#83151d491b3016b3c05a71a13736209e">GClasses::GIncrementalLearner</a>.</p>

</div>
</div><p>
<a class="anchor" name="7036305f9314fb60778596fa7f19c34d"></a><!-- doxytag: member="GClasses::GTransducer::crossValidate" ref="7036305f9314fb60778596fa7f19c34d" args="(GData *pData, int nFolds, int labelDims, RepValidateCallback pCB=NULL, int nRep=0, void *pThis=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GTransducer::crossValidate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nFolds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>labelDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_g_classes.html#4e2f99ff8c7fd6755d3d32a025500b3b">RepValidateCallback</a>&nbsp;</td>
          <td class="paramname"> <em>pCB</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nRep</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pThis</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform n-fold cross validation on pData. Uses trainAndTest for each fold. pCB is an optional callback method for reporting intermediate stats. It can be NULL if you don't want intermediate reporting. nRep is just the rep number that will be passed to the callback. pThis is just a pointer that will be passed to the callback for you to use however you want. It doesn't affect this method. The results of each fold is returned in a dataset. 
<p>

</div>
</div><p>
<a class="anchor" name="c2c140ad19628ad9f527fd748ccc66c7"></a><!-- doxytag: member="GClasses::GTransducer::heuristicValidate" ref="c2c140ad19628ad9f527fd748ccc66c7" args="(GData *pData, int labelDims, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GTransducer::heuristicValidate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>labelDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This performs two-fold cross-validation on a shuffled non-uniform split of the data, and returns an error value that represents the results of all labels combined. (This is for heuristic optimization, not for reporting accuracy.). 
<p>

</div>
</div><p>
<a class="anchor" name="606b4211dd74510df18fc6ba539346a3"></a><!-- doxytag: member="GClasses::GTransducer::repValidate" ref="606b4211dd74510df18fc6ba539346a3" args="(GData *pData, int nReps, int nFolds, int labelDims, GRand *pRand, RepValidateCallback pCB=NULL, void *pThis=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GTransducer::repValidate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nReps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nFolds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>labelDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_g_classes.html#4e2f99ff8c7fd6755d3d32a025500b3b">RepValidateCallback</a>&nbsp;</td>
          <td class="paramname"> <em>pCB</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pThis</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform cross validation "nReps" times and return the average score. (5 reps with 2 folds is preferred over 10-fold cross validation because it yields less type 1 error.) pCB is an optional callback method for reporting intermediate stats It can be NULL if you don't want intermediate reporting. pThis is just a pointer that will be passed to the callback for you to use however you want. It doesn't affect this method. The results of each fold is returned in a dataset. 
<p>

</div>
</div><p>
<a class="anchor" name="a323b06012fe8974233026d441253408"></a><!-- doxytag: member="GClasses::GTransducer::trainAndTest" ref="a323b06012fe8974233026d441253408" args="(GData *pTrainingSet, GData *pTestSet, int labelDims, double *pOutResults)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GClasses::GTransducer::trainAndTest           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pTrainingSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pTestSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>labelDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutResults</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Trains and tests this learner. pOutResults should have an element for each label dim. 
<p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_supervised_learner.html#694dd4a768bfa35fe00a29f2afd8dd23">GClasses::GSupervisedLearner</a>.</p>

</div>
</div><p>
<a class="anchor" name="a0f11b6006bee48f545335a3a028dd25"></a><!-- doxytag: member="GClasses::GTransducer::transduce" ref="a0f11b6006bee48f545335a3a028dd25" args="(GData *pDataLabeled, GData *pDataUnlabeled, int labelDims)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GClasses::GTransducer::transduce           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pDataLabeled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pDataUnlabeled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>labelDims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Trains with pDataLabeled, and then predicts labels for all the rows in pDataUnlabeled. (Works with model-free algorithms that cannot be trained.) The rows in pDataUnlabeled are expected to have space allocated for labels, but the values will be overwritten with the predicted values. 
<p>

<p>Implemented in <a class="el" href="class_g_classes_1_1_g_agglomerative_transducer.html#06ee71950236e074091dd558b9ce189d">GClasses::GAgglomerativeTransducer</a>, <a class="el" href="class_g_classes_1_1_g_graph_cut_transducer.html#a9b3ab9b7975bfe220d9aa8f3c03f707">GClasses::GGraphCutTransducer</a>, <a class="el" href="class_g_classes_1_1_g_neighbor_transducer.html#c0716428baac326dbd48a321038cfcb5">GClasses::GNeighborTransducer</a>, and <a class="el" href="class_g_classes_1_1_g_supervised_learner.html#df915fe0a2bb07f86c3918db4cc1307a">GClasses::GSupervisedLearner</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Nov 2 14:18:24 2010 for GClasses by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
