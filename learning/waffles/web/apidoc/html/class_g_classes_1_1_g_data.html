<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>GClasses: GClasses::GData Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_g_classes.html">GClasses</a>::<a class="el" href="class_g_classes_1_1_g_data.html">GData</a>
  </div>
</div>
<div class="contents">
<h1>GClasses::GData Class Reference</h1><!-- doxytag: class="GClasses::GData" -->Represents a matrix or a database table. Elements can be discrete or continuous. References a <a class="el" href="class_g_classes_1_1_g_relation.html" title="Holds the metadata for a dataset, including which attributes are continuous or nominal...">GRelation</a> object, which stores the meta-information about each column.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;GData.h&gt;</code>
<p>

<p>
<a href="class_g_classes_1_1_g_data-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#75fc4af29bbb49c72d0243df851e3950">GData</a> (<a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;pRelation, <a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *pHeap=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pRelation is a smart-pointer to a relation, which specifies the type of each attribute.  <a href="#75fc4af29bbb49c72d0243df851e3950"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#0a5d47de505b1797418e3dedac9dd1e2">GData</a> (int attrs, <a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *pHeap=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">attrs specifies the number of attributes. All attributes will be real-valued.  <a href="#0a5d47de505b1797418e3dedac9dd1e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#b71c83aefd194a3dc4023c36be0d8d96">GData</a> (<a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a> *pNode, <a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *pHeap=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a dataset from a text-based format.  <a href="#b71c83aefd194a3dc4023c36be0d8d96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#1ceb701dc07608384a02bd25fa1fba3f">~GData</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#5a1ceef7a33da72a4af043f54c3039d7">add</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pThat, bool transpose)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix add. Adds the values in pThat to this. (If transpose is true, adds the transpose of pThat to this.) Both datasets must have the same dimensions. Behavior is undefined for nominal columns.  <a href="#5a1ceef7a33da72a4af043f54c3039d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#a6f15df8178f77afb02672c7db7da82d">attrSubset</a> (int firstAttr, int attrCount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new dataset that contains a subset of the attributes in this dataset.  <a href="#a6f15df8178f77afb02672c7db7da82d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#5d7ff2bdf2a47e2954542621b6c78a69">cholesky</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This computes the square root of this matrix. (If you take the matrix that this returns and multiply it by its transpose, you should get the original dataset again.) Behavior is undefined if there are nominal attributes. If this matrix is not positive definate, it will throw an exception.  <a href="#5d7ff2bdf2a47e2954542621b6c78a69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#1c25758106b0962d17a7da4f97ae781a">clone</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes a copy of this dataset.  <a href="#1c25758106b0962d17a7da4f97ae781a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#77f9f64f7ca8a503b4e06f873e9fa0ea">col</a> (int index, double *pOutVector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the specified column into pOutVector.  <a href="#77f9f64f7ca8a503b4e06f873e9fa0ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#d75aa0cfef8e4c5f6c74a12123fa4ce1">cols</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of columns in the dataset.  <a href="#d75aa0cfef8e4c5f6c74a12123fa4ce1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#bd9ba3212afaf6b4e469190fbb272945">copy</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pThat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies all the data from pThat. (Just references the same relation).  <a href="#bd9ba3212afaf6b4e469190fbb272945"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#ecae98ffcde0865b051ba323d1222fd4">copyColumns</a> (int nDestStartColumn, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pSource, int nSourceStartColumn, int nColumnCount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the specified block of columns from pSource to this dataset. pSource must have the same number of rows as this dataset.  <a href="#ecae98ffcde0865b051ba323d1222fd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#d5e6425aaa1f56f15e01ad2741d6c64a">copyRow</a> (const double *pRow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the row to the data set.  <a href="#d5e6425aaa1f56f15e01ad2741d6c64a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#d7a245c771093352f275f0f69cf0e3c1">determinant</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the determinant of this matrix.  <a href="#d7a245c771093352f275f0f69cf0e3c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#dbe75d8d17e5695eaac940980ca5a708">eigenValue</a> (const double *pEigenVector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the eigenvalue that corresponds to the specified eigenvector of this matrix.  <a href="#dbe75d8d17e5695eaac940980ca5a708"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#abf01d008a38ae76bf53e58aa71da576">eigenVector</a> (double eigenvalue, double *pOutVector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the eigenvector that corresponds to the specified eigenvalue of this matrix. Note that this method trashes this matrix, so make a copy first if you care.  <a href="#abf01d008a38ae76bf53e58aa71da576"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#2851185a319827c139d09d675f9e6408">gaussianElimination</a> (double *pVector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes y in the equation M*y=x (or y=M^(-1)x), where M is this dataset, which must be a square matrix, and x is pVector as passed in, and y is pVector after the call. If there are multiple solutions, it finds the one for which all the variables in the null-space have a value of 1. If there are no solutions, it returns false. Note that this method trashes this dataset (so make a copy first if you care).  <a href="#2851185a319827c139d09d675f9e6408"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#6f20b0c5dc0b824d139895926412b4b7">heap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the heap used to allocate rows for this dataset.  <a href="#6f20b0c5dc0b824d139895926412b4b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#c18aa0f642d05c1d2550da1f4015552c">makeIdentity</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets this dataset to an identity matrix. (It doesn't change the number of columns or rows. It just stomps over existing values.).  <a href="#c18aa0f642d05c1d2550da1f4015552c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#512fddd1133f0cff58b5a7b18a959fe7">mirrorTriangle</a> (bool upperToLower)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If upperToLower is true, copies the upper triangle of this matrix over the lower triangle If upperToLower is false, copies the lower triangle of this matrix over the upper triangle.  <a href="#512fddd1133f0cff58b5a7b18a959fe7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#b190f433d841de713b1edd64212c4f6a">mergeVert</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Steals all the rows from pData and adds them to this set. (You still have to delete pData.) Both datasets must have the same number of columns.  <a href="#b190f433d841de713b1edd64212c4f6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#ef8daeab02484fd2d56b956f9ad73d27">eigs</a> (int nCount, double *pEigenVals, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand, bool mostSignificant)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes nCount eigenvectors and the corresponding eigenvalues using the power method. (This method is only accurate if a small number of eigenvalues/vectors are needed.) If mostSignificant is true, the largest eigenvalues are found. If mostSignificant is false, the smallest eigenvalues are found.  <a href="#ef8daeab02484fd2d56b956f9ad73d27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#2e538733e0b79c8ec550685261f6fe92">multiply</a> (double scalar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies every element in the dataset by scalar. Behavior is undefined for nominal columns.  <a href="#2e538733e0b79c8ec550685261f6fe92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#9187067dc8bdb66c56fbc86455029e43">multiply</a> (const double *pVectorIn, double *pVectorOut, bool transpose=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies this matrix by the column vector pVectorIn to get pVectorOut. (If transpose is true, then it multiplies the transpose of this matrix by pVectorIn to get pVectorOut.) pVectorIn should have the same number of elements as columns (or rows if transpose is true) and pVectorOut should have the same number of elements as rows (or cols, if transpose is true.) Note that if transpose is true, it is the same as if pVectorIn is a row vector and you multiply it by this matrix to get pVectorOut.  <a href="#9187067dc8bdb66c56fbc86455029e43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#1a786f3f221a2f7c8f48855a472d8ee5">newRow</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a new row to the dataset. (The values in the row are not initialized).  <a href="#1a786f3f221a2f7c8f48855a472d8ee5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#cb1aef66247943db7e0303080616d3bc">newRows</a> (size_t nRows)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds "nRows" uninitialized rows of size "nAttributes" to the data set.  <a href="#cb1aef66247943db7e0303080616d3bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#d9ccdd23640cc90ee34535a37f2ac410">pseudoInverse</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the Moore-Penrose pseudoinverse of this matrix (using the SVD method). You are responsible to delete the matrix this returns.  <a href="#d9ccdd23640cc90ee34535a37f2ac410"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#7809945ef1f0dfd13f9d9d91fb68f3ef">relation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a relation object, which holds meta-data about the attributes (columns).  <a href="#7809945ef1f0dfd13f9d9d91fb68f3ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#abd3a7ab24db6a0faf054d225b206b30">reserve</a> (size_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates space for the specified number of patters (to avoid superfluous resizing).  <a href="#abd3a7ab24db6a0faf054d225b206b30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#2ec481f296ab65163e30d51513f25e6c">rows</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of rows in the dataset.  <a href="#2ec481f296ab65163e30d51513f25e6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#e05530098714f10b8ffa6d12107d3f74">saveArff</a> (const char *szFilename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves the dataset to a file in ARFF format.  <a href="#e05530098714f10b8ffa6d12107d3f74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#01acd8108435a42c67f693b4e5b31a5c">setRelation</a> (<a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;pRelation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the relation for this dataset.  <a href="#01acd8108435a42c67f693b4e5b31a5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#a14785165dfd06f14a36944cc575011c">singularValueDecomposition</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> **ppU, double **ppDiag, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> **ppV, bool throwIfNoConverge=false, int maxIters=80)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs SVD on A, where A is this m-by-n matrix. *ppU will be set to an m-by-m matrix where the columns are the eigenvectors of A(A^T). *ppDiag will be set to an array of n doubles holding the square roots of the corresponding eigenvalues. *ppV will be set to an n-by-n matrix where the rows are the eigenvectors of (A^T)A. You are responsible to delete(*ppU), delete(*ppV), and delete[] *ppDiag.  <a href="#a14785165dfd06f14a36944cc575011c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#c7fad799a9bc665dc9a9d66ca80d0ca7">subtract</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pThat, bool transpose)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix subtract. Subtracts the values in pThat from this. (If transpose is true, subtracts the transpose of pThat from this.) Both datasets must have the same dimensions. Behavior is undefined for nominal columns.  <a href="#c7fad799a9bc665dc9a9d66ca80d0ca7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#bcd1d1ed2f4272c1f9c58c4f2bb1e5be">sumSquaredDiffWithIdentity</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the sum squared difference between this matrix and an identity matrix.  <a href="#bcd1d1ed2f4272c1f9c58c4f2bb1e5be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#f5787ef975452a5fd762b6cb77cab833">takeRow</a> (double *pRow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an already-allocated row to this dataset. The row must be allocated in the same heap that this dataset uses. (There is no way for this method to verify that, so be careful.).  <a href="#f5787ef975452a5fd762b6cb77cab833"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#5db75722761658872985ca9a5b463931">toReducedRowEchelonForm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the matrix to reduced row echelon form.  <a href="#5db75722761658872985ca9a5b463931"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#b289f9bc96a6a551730569628c5529c6">toVector</a> (double *pVector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies all the data from this dataset into pVector. pVector must be big enough to hold <a class="el" href="class_g_classes_1_1_g_data.html#2ec481f296ab65163e30d51513f25e6c" title="Returns the number of rows in the dataset.">rows()</a> x <a class="el" href="class_g_classes_1_1_g_data.html#d75aa0cfef8e4c5f6c74a12123fa4ce1" title="Returns the number of columns in the dataset.">cols()</a> doubles.  <a href="#b289f9bc96a6a551730569628c5529c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#d8fa15e3bb45b9aaafd76c472b756d7c">toTwt</a> (<a class="el" href="class_g_classes_1_1_g_twt_doc.html">GTwtDoc</a> *pDoc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes data to a text file in ".twt" format.  <a href="#d8fa15e3bb45b9aaafd76c472b756d7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#80052a0c630caa79be8b7eaa7457d519">trace</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the sum of the diagonal elements.  <a href="#80052a0c630caa79be8b7eaa7457d519"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#6b9af7ce058444469db0b7227e1228c4">transpose</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a dataset that is this dataset transposed. (All columns in the returned dataset will be continuous.).  <a href="#6b9af7ce058444469db0b7227e1228c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#43b13c021bfe74b1e532cc0aa8e38129">fromVector</a> (const double *pVector, size_t nRows)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the data from pVector over this dataset. nRows specifies the number of rows of data in pVector.  <a href="#43b13c021bfe74b1e532cc0aa8e38129"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#040031eeca3825a4bf485acba62168d9">row</a> (size_t index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the specified row.  <a href="#040031eeca3825a4bf485acba62168d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#3fea5d763706a9529656d9ee9e801e4d">operator[]</a> (size_t index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the specified row.  <a href="#3fea5d763706a9529656d9ee9e801e4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#c654d807bdffbdee3b68b5e44e0637dd">setAll</a> (double val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets all elements in this dataset to the specified value.  <a href="#c654d807bdffbdee3b68b5e44e0637dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#e9c148a23066815fd0a86a9fcb67fcd6">setCol</a> (int index, const double *pVector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies pVector over the specified column.  <a href="#e9c148a23066815fd0a86a9fcb67fcd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#b43ec600d08405e05b2949f54d132f3f">replaceRow</a> (size_t nIndex, double *pRow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps pRow with the row at nIndex. You're responsible to delete the row this returns.  <a href="#b43ec600d08405e05b2949f54d132f3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#7467e46b6901fe6880e19812370e8a8b">swapRows</a> (size_t a, size_t b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the two specified rows.  <a href="#7467e46b6901fe6880e19812370e8a8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#5448aec5af95c4a7317167b4faa1fd90">swapColumns</a> (int nAttr1, int nAttr2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps two columns.  <a href="#5448aec5af95c4a7317167b4faa1fd90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#af6a18854b83dfcf104c7922271db72f">deleteColumn</a> (int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a column.  <a href="#af6a18854b83dfcf104c7922271db72f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#879bf4be4edac53d6bee85e1b4d395e6">releaseRow</a> (size_t index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the specified row with the last row, and then releases it from the dataset. If this dataset does not have its own heap, then you must delete the row this returns.  <a href="#879bf4be4edac53d6bee85e1b4d395e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#8afb2fd7d49e54dd0953597e8291f085">deleteRow</a> (size_t index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the specified row with the last row, and then deletes it.  <a href="#8afb2fd7d49e54dd0953597e8291f085"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#443deea99f259889700f88edd793d9f6">releaseRowPreserveOrder</a> (size_t index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases the specified row from the dataset and shifts everything after it up one slot. If this dataset does not have its own heap, then you must delete the row this returns.  <a href="#443deea99f259889700f88edd793d9f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#d21ce9f147302613abaa4a2327229bf7">deleteRowPreserveOrder</a> (size_t index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the specified row and shifts everything after it up one slot.  <a href="#d21ce9f147302613abaa4a2327229bf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#279731629d5f14684d49e652692a311a">fixNans</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces any occurrences of NAN in the matrix with the corresponding values from an identity matrix.  <a href="#279731629d5f14684d49e652692a311a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#52fac7585adc59fdbe9713a320273f46">flush</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes all the data.  <a href="#52fac7585adc59fdbe9713a320273f46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#0553e6ba1aeabbe7d80ec9f4f4e7dee7">releaseAllRows</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abandons (leaks) all the rows of data.  <a href="#0553e6ba1aeabbe7d80ec9f4f4e7dee7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#3403568b2750bb2f315fe0b3339a0a61">shuffle</a> (<a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Randomizes the order of the rows.  <a href="#3403568b2750bb2f315fe0b3339a0a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#b253922d7acbad99853d0678a9c170a4">shuffle2</a> (<a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shuffles the order of the rows. Also shuffles the rows in "other" in the same way, such that corresponding rows are preserved.  <a href="#b253922d7acbad99853d0678a9c170a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#eb8dfcd9491c53e6dfcf1843ec775d88">shuffleLikeCards</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an inferior way to shuffle the data.  <a href="#eb8dfcd9491c53e6dfcf1843ec775d88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#16a682d8063f84c74b010da458c619d9">sort</a> (int nDimension)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data from smallest to largest in the specified dimension.  <a href="#16a682d8063f84c74b010da458c619d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#7c221e7aec118a7d7f707d0de733d872">reverseRows</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverses the row order.  <a href="#7c221e7aec118a7d7f707d0de733d872"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename CompareFunc &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#2a6c45c34c45b8361d8fb6a2aac168d8">sort</a> (CompareFunc &amp;pComparator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts rows according to the specified compare function. (Return true to indicate thate the first row comes before the second row.).  <a href="#2a6c45c34c45b8361d8fb6a2aac168d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#337e2cad435a263e1d80c0d7e7fc0cd5">splitByPivot</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pGreaterOrEqual, int nAttribute, double dPivot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Splits this set of data into two sets. Values greater-than-or-equal-to dPivot stay in this data set. Values less than dPivot go into pLessThanPivot.  <a href="#337e2cad435a263e1d80c0d7e7fc0cd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#1e92f2186659580a645848b5787ec15d">splitByDiscreteValue</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pSingleClass, int nAttr, int nValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves all rows with the specified value in the specified attribute into pSingleClass.  <a href="#1e92f2186659580a645848b5787ec15d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#47c0b3c582fafd9742c60a1ca929c7c8">splitBySize</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pOtherData, size_t nOtherRows)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the last nOtherRows rows from this data set and puts them in pOtherData.  <a href="#47c0b3c582fafd9742c60a1ca929c7c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#1ce5c716e389fe0419595096264fb5b9">entropy</a> (int nColumn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Measures the entropy of the specified attribute.  <a href="#1ce5c716e389fe0419595096264fb5b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#ab6941c932b870db7dae3ce6f90043b6">minAndRange</a> (int nAttribute, double *pMin, double *pRange)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the min and the range of the values of the specified attribute.  <a href="#ab6941c932b870db7dae3ce6f90043b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#3f8d4a21a28e22db52c8f6d71767e4df">minAndRangeUnbiased</a> (int nAttribute, double *pMin, double *pRange)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimates the actual min and range based on a random sample.  <a href="#3f8d4a21a28e22db52c8f6d71767e4df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#aa7070af25cc2abb5f2d84820d2ac34c">centerMeanAtOrigin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shifts the data such that the mean occurs at the origin.  <a href="#aa7070af25cc2abb5f2d84820d2ac34c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#ad290200e2954da1a2f419d65c1ca66a">mean</a> (int nAttribute)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the arithmetic mean of the values in the specified column.  <a href="#ad290200e2954da1a2f419d65c1ca66a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#25a5dec09c883d258b01e281a155fbcb">median</a> (int nAttribute)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the median of the values in the specified column.  <a href="#25a5dec09c883d258b01e281a155fbcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#e41cd512604b43e8b592ca138c252e36">centroid</a> (double *pOutCentroid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the arithmetic means of all attributes.  <a href="#e41cd512604b43e8b592ca138c252e36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#3cd6bc315143a5d96b6bde15a7eba300">variance</a> (int nAttr, double mean)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the average variance of a single attribute.  <a href="#3cd6bc315143a5d96b6bde15a7eba300"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#dd0df3525d45b21328ca4388aa35dbac">normalize</a> (int nAttribute, double dInputMin, double dInputRange, double dOutputMin, double dOutputRange)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalizes the specified attribute values.  <a href="#dd0df3525d45b21328ca4388aa35dbac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#457fb449f7c8d909759b6ec240164c03">baselineValue</a> (int nAttribute)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the mean (for continuous attributes) or the most common value (for nominal attributes).  <a href="#457fb449f7c8d909759b6ec240164c03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#8aa91d0027a7abb392d223568641fec6">baselineVector</a> (int nOutputCount, double *pOutputs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Produce an output row with the most common output (for nominal attributes) and the mean (for continuous attributes).  <a href="#8aa91d0027a7abb392d223568641fec6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#cf71982509515eeb03f6eb177b07bca1">isAttrHomogenous</a> (int col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true iff the specified attribute contains homogenous values. (Unknowns are counted as homogenous with anything).  <a href="#cf71982509515eeb03f6eb177b07bca1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#c3126bada30adbd8f8fbc283cf9308b2">areLabelsHomogenous</a> (int labelDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true iff each of the last labelDims columns in the data are homogenous.  <a href="#c3126bada30adbd8f8fbc283cf9308b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#7db046b1dfb8b83d87f868a2ee880583">randomlyReplaceMissingValues</a> (int nAttr, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all missing values by copying a randomly selected non-missing value in the same attribute (This messes up the order of the rows because it uses sorting to find the missing values, so you should probably call Shuffle() when you're done calling this method.).  <a href="#7db046b1dfb8b83d87f868a2ee880583"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#b0a8f97364885251437b1fa1232f8b67">principalComponent</a> (double *pOutVector, int dims, const double *pMean, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an efficient algorithm for iteratively computing the principal component vector (the eigenvector of the covariance matrix) of the data. See "EM Algorithms for PCA and SPCA" by Sam Roweis, 1998 NIPS. nIterations should be a small constant. 20 seems work well for most applications. (To compute the next principal component, call RemoveComponent, then call this again.).  <a href="#b0a8f97364885251437b1fa1232f8b67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#50a542d0f229a3780f7e8657cafc36ab">principalComponentAboutOrigin</a> (double *pOutVector, int dims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the first principal component assuming the mean is already subtracted out of the data.  <a href="#50a542d0f229a3780f7e8657cafc36ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#01c735e82a5f9bae229b28f80f9e3559">principalComponentIgnoreUnknowns</a> (double *pOutVector, int dims, const double *pMean, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes principal components, while ignoring missing values.  <a href="#01c735e82a5f9bae229b28f80f9e3559"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#67f2713275628a9b0c5763672f89ff5a">weightedPrincipalComponent</a> (double *pOutVector, int dims, const double *pMean, const double *pWeights, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the first principal component of the data with each row weighted according to the vector pWeights. (pWeights must have an element for each row.).  <a href="#67f2713275628a9b0c5763672f89ff5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#b81698323e75c023cfd8de4804290963">eigenValue</a> (const double *pMean, const double *pEigenVector, int dims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">After you compute the principal component, you can call this to obtain the eigenvalue that corresponds to that principal component vector (eigenvector).  <a href="#b81698323e75c023cfd8de4804290963"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#9311947fa00ec06850cefa4fddb136e9">removeComponent</a> (const double *pMean, const double *pComponent, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the component specified by pComponent from the data. (pComponent should already be normalized.) This might be useful, for example, to remove the first principal component from the data so you can then proceed to compute the second principal component, and so forth.  <a href="#9311947fa00ec06850cefa4fddb136e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#19faad94e458e3f4015ef32256da95e3">removeComponentAboutOrigin</a> (const double *pComponent, int dims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the specified component assuming the mean is zero.  <a href="#19faad94e458e3f4015ef32256da95e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#bae1ea54269fcb9d3c3d844076a7c95e">countPrincipalComponents</a> (double d, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the minimum number of principal components necessary so that less than the specified portion of the deviation in the data is unaccounted for. (For example, if the data projected onto the first 3 principal components contains 90 percent of the deviation that the original data contains, then if you pass the value 0.1 to this method, it will return 3.).  <a href="#bae1ea54269fcb9d3c3d844076a7c95e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#67984f3368039d0d1e9ff5887d3c9571">sumSquaredDistance</a> (const double *pPoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sum-squared distance between pPoint and all of the points in the dataset. (If pPoint is NULL, it computes the sum-squared distance with the origin.) (Note that this is equal to the sum of all the eigenvalues times the number of dimensions, so you can efficiently compute eigenvalues as the difference in sumSquaredDistance with the mean after removing the corresponding component, and then dividing by the number of dimensions. This is more efficient than calling eigenValue.).  <a href="#67984f3368039d0d1e9ff5887d3c9571"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#67b4ee5797d5dc1439f1d573d2422cde">sumSquaredDifference</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> &amp;that, bool transpose=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the squared distance between this and that. (If transpose is true, computes the difference between this and the transpose of that.).  <a href="#67b4ee5797d5dc1439f1d573d2422cde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#da6914865c5d462586616b3f9c391934">linearCorrelationCoefficient</a> (int attr1, double attr1Origin, int attr2, double attr2Origin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the linear coefficient between the two specified attributes. Usually you will want to pass the mean values for attr1Origin and attr2Origin.  <a href="#da6914865c5d462586616b3f9c391934"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#9885c08e02cb6df1364f8ed9b20f76f1">covariance</a> (int nAttr1, double dMean1, int nAttr2, double dMean2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the covariance between two attributes.  <a href="#9885c08e02cb6df1364f8ed9b20f76f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#af392277b698a2df79298d2185155c15">covarianceMatrix</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the covariance matrix of the data.  <a href="#af392277b698a2df79298d2185155c15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#34cc4df701b28b65fafd371fd3ad0d20">pairedTTest</a> (int *pOutV, double *pOutT, int attr1, int attr2, bool normalize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a paired T-Test with data from the two specified attributes. pOutV will hold the degrees of freedom. pOutT will hold the T-value. You can use <a class="el" href="class_g_classes_1_1_g_math.html#e19ea9621f599142d2ebb3ad0ff37404" title="Computes the p-value from the degrees of freedom, and the t-value obtained from a...">GMath::tTestAlphaValue</a> to convert these to a P-value.  <a href="#34cc4df701b28b65fafd371fd3ad0d20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#924e656e95432de6d081bf5210d42ccb">wilcoxonSignedRanksTest</a> (int attr1, int attr2, double tolerance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs the Wilcoxon signed ranks test from the two specified attributes and returns the T-value. If two values are closer than tolerance, they are considered to be equal.  <a href="#924e656e95432de6d081bf5210d42ccb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#2621fb5460f84216bb382f0bf7979ad6">print</a> (std::ostream &amp;stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the data to the specified stream.  <a href="#2621fb5460f84216bb382f0bf7979ad6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#b9a77d96c3583a0e7116ea06c9b11b6e">countValue</a> (int attribute, double value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of ocurrences of the specified value in the specified attribute.  <a href="#b9a77d96c3583a0e7116ea06c9b11b6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#fa2d9e56b41720f51444d0d33af35018">ensureDataHasNoMissingReals</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throws an exception if this data contains any missing values in a continuous attribute.  <a href="#fa2d9e56b41720f51444d0d33af35018"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#df366689e89e87e22d998bb4ee1463ad">ensureDataHasNoMissingNominals</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throws an exception if this data contains any missing values in a nominal attribute.  <a href="#df366689e89e87e22d998bb4ee1463ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#4128831cacb2e74ffbbc7e12cb4c7549">measureLabelInfo</a> (int labelDims)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the entropy of the labels (or the deviation if continuous).  <a href="#4128831cacb2e74ffbbc7e12cb4c7549"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#b0e51489d293c7d07c65c6f2466bcc3e">leastCorrelatedVector</a> (double *pOut, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pThat, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the vector in this subspace that has the greatest distance from its projection into pThat subspace. Returns true if the results are computed. Returns false if the subspaces are so nearly parallel that pOut cannot be computed with accuracy.  <a href="#b0e51489d293c7d07c65c6f2466bcc3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#84a7b079dbae340a1c83d4b87d2079cf">dihedralCorrelation</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pThat, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the cosine of the dihedral angle between this subspace and pThat subspace.  <a href="#84a7b079dbae340a1c83d4b87d2079cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#d4d13175c82a71e7d9c4c821ceb2f74f">project</a> (double *pDest, const double *pPoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Projects pPoint onto this hyperplane (where each row defines one of the orthonormal basis vectors of this hyperplane) This computes (A^T)Ap, where A is this matrix, and p is pPoint.  <a href="#d4d13175c82a71e7d9c4c821ceb2f74f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#f7645c929afb9621b326dc6baabd7cb9">project</a> (double *pDest, const double *pPoint, const double *pOrigin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Projects pPoint onto this hyperplane (where each row defines one of the orthonormal basis vectors of this hyperplane).  <a href="#f7645c929afb9621b326dc6baabd7cb9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#c1278fda726094c1c731449341c9caf7">kabsch</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pA, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This computes K=kabsch(A,B), such that K is an n-by-n matrix, where n is pA-&gt;<a class="el" href="class_g_classes_1_1_g_data.html#d75aa0cfef8e4c5f6c74a12123fa4ce1" title="Returns the number of columns in the dataset.">cols()</a>. K is the optimal orthonormal rotation matrix to align A and B, such that A(K^T) minimizes sum-squared error with B, and BK minimizes sum-squared error with A. (This rotates around the origin, so typically you will want to subtract the centroid from both pA and pB before calling this.).  <a href="#c1278fda726094c1c731449341c9caf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#f4f120927b5c30a0f4cdddba682824b8">align</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pA, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This uses the Kabsch algorithm to rotate and translate pB in order to minimize RMS with pA. (pA and pB must have the same number of rows and columns.).  <a href="#f4f120927b5c30a0f4cdddba682824b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#3ee092c8c796d5934eb7e9d9996b75d7">loadArff</a> (const char *szFilename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads an ARFF file and returns the data. This will throw an exception if there's an error.  <a href="#3ee092c8c796d5934eb7e9d9996b75d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#0842c4a9552c35a125da0736100ef573">loadCsv</a> (const char *szFilename, char separator, bool columnNamesInFirstRow, bool tolerant)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a file in CSV format.  <a href="#0842c4a9552c35a125da0736100ef573"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#b35480e4b2ce76878860c46965b9baed">mergeHoriz</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pSetA, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pSetB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merges two datasets side-by-side. The resulting dataset will contain the attributes of both datasets. Both pSetA and pSetB (and the resulting dataset) must have the same number of rows.  <a href="#b35480e4b2ce76878860c46965b9baed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#4f3e1da8966366e52a247d3e043ff126">multiply</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> &amp;a, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> &amp;b, bool transposeA, bool transposeB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix multiply. For convenience, you can also specify that neither, one, or both of the inputs are virtually transposed prior to the multiplication. (If you want the results to come out transposed, you can use the equality AB=((B^T)(A^T))^T to figure out how to specify the parameters.).  <a href="#4f3e1da8966366e52a247d3e043ff126"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#0d3567afb8631eb587c01230a4c56129">parseArff</a> (const char *szFile, size_t nLen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses an ARFF file and returns the data. This will throw an exception if there's an error.  <a href="#0d3567afb8631eb587c01230a4c56129"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#3b44b62453226a035403be077f949006">parseCsv</a> (const char *pFile, size_t len, char separator, bool columnNamesInFirstRow, bool tolerant=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Imports data from a text file. Determines the meta-data automatically. Note: This method does not support Mac line-endings. You should first replace all '' with '<br>
' if your data comes from a Mac. As a special case, if separator is '', then it assumes data elements are separated by any number of whitespace characters, that element values themselves contain no whitespace, and that there are no missing elements. (This is the case when you save a Matlab matrix to an ascii file.).  <a href="#3b44b62453226a035403be077f949006"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#1a31ee9795f5562ac672213fa4faa670">normalize</a> (double dVal, double dInputMin, double dInputRange, double dOutputMin, double dOutputRange)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize a value from the input min and range to the output min and range.  <a href="#1a31ee9795f5562ac672213fa4faa670"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#5945408aee842ec9a8442e4ead2a574f">test</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs unit tests for this class. Throws an exception if there is a failure.  <a href="#5945408aee842ec9a8442e4ead2a574f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#d5f9d47417117e4e5096d2263e8451d6">determinantHelper</a> (int nEndRow, int *pColumnList)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#23031cea0cf4067dfa4d0783bbab3b3b">inPlaceSquareTranspose</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#0a4c50b66fdea1955a5c7251229e69c6">singularValueDecompositionHelper</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> **ppU, double **ppDiag, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> **ppV, bool throwIfNoConverge, int maxIters)</td></tr>

<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#97a7f75513c28daef372d6e74bdc1c7c">parseDataRow</a> (<a class="el" href="class_g_classes_1_1_g_arff_relation.html">GArffRelation</a> *pRelation, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pData, const char *szFile, size_t nLen, int nLine)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#7f259cdc99e7bf1b4b43f308edaef00b">m_pRelation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#48e28e6df1bbed0b20656e178f2c964b">m_pHeap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html#328eb6db165c5a9c4b08939f9b1eb416">m_rows</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Represents a matrix or a database table. Elements can be discrete or continuous. References a <a class="el" href="class_g_classes_1_1_g_relation.html" title="Holds the metadata for a dataset, including which attributes are continuous or nominal...">GRelation</a> object, which stores the meta-information about each column. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="75fc4af29bbb49c72d0243df851e3950"></a><!-- doxytag: member="GClasses::GData::GData" ref="75fc4af29bbb49c72d0243df851e3950" args="(sp_relation &amp;pRelation, GHeap *pHeap=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GData::GData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pRelation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *&nbsp;</td>
          <td class="paramname"> <em>pHeap</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
pRelation is a smart-pointer to a relation, which specifies the type of each attribute. 
<p>

</div>
</div><p>
<a class="anchor" name="0a5d47de505b1797418e3dedac9dd1e2"></a><!-- doxytag: member="GClasses::GData::GData" ref="0a5d47de505b1797418e3dedac9dd1e2" args="(int attrs, GHeap *pHeap=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GData::GData           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *&nbsp;</td>
          <td class="paramname"> <em>pHeap</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
attrs specifies the number of attributes. All attributes will be real-valued. 
<p>

</div>
</div><p>
<a class="anchor" name="b71c83aefd194a3dc4023c36be0d8d96"></a><!-- doxytag: member="GClasses::GData::GData" ref="b71c83aefd194a3dc4023c36be0d8d96" args="(GTwtNode *pNode, GHeap *pHeap=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GData::GData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a> *&nbsp;</td>
          <td class="paramname"> <em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *&nbsp;</td>
          <td class="paramname"> <em>pHeap</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads a dataset from a text-based format. 
<p>

</div>
</div><p>
<a class="anchor" name="1ceb701dc07608384a02bd25fa1fba3f"></a><!-- doxytag: member="GClasses::GData::~GData" ref="1ceb701dc07608384a02bd25fa1fba3f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GData::~GData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5a1ceef7a33da72a4af043f54c3039d7"></a><!-- doxytag: member="GClasses::GData::add" ref="5a1ceef7a33da72a4af043f54c3039d7" args="(GData *pThat, bool transpose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::add           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pThat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>transpose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Matrix add. Adds the values in pThat to this. (If transpose is true, adds the transpose of pThat to this.) Both datasets must have the same dimensions. Behavior is undefined for nominal columns. 
<p>

</div>
</div><p>
<a class="anchor" name="f4f120927b5c30a0f4cdddba682824b8"></a><!-- doxytag: member="GClasses::GData::align" ref="f4f120927b5c30a0f4cdddba682824b8" args="(GData *pA, GData *pB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::align           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This uses the Kabsch algorithm to rotate and translate pB in order to minimize RMS with pA. (pA and pB must have the same number of rows and columns.). 
<p>

</div>
</div><p>
<a class="anchor" name="c3126bada30adbd8f8fbc283cf9308b2"></a><!-- doxytag: member="GClasses::GData::areLabelsHomogenous" ref="c3126bada30adbd8f8fbc283cf9308b2" args="(int labelDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GClasses::GData::areLabelsHomogenous           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>labelDims</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true iff each of the last labelDims columns in the data are homogenous. 
<p>

</div>
</div><p>
<a class="anchor" name="a6f15df8178f77afb02672c7db7da82d"></a><!-- doxytag: member="GClasses::GData::attrSubset" ref="a6f15df8178f77afb02672c7db7da82d" args="(int firstAttr, int attrCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::attrSubset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>firstAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attrCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a new dataset that contains a subset of the attributes in this dataset. 
<p>

</div>
</div><p>
<a class="anchor" name="457fb449f7c8d909759b6ec240164c03"></a><!-- doxytag: member="GClasses::GData::baselineValue" ref="457fb449f7c8d909759b6ec240164c03" args="(int nAttribute)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::baselineValue           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttribute</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines the mean (for continuous attributes) or the most common value (for nominal attributes). 
<p>

</div>
</div><p>
<a class="anchor" name="8aa91d0027a7abb392d223568641fec6"></a><!-- doxytag: member="GClasses::GData::baselineVector" ref="8aa91d0027a7abb392d223568641fec6" args="(int nOutputCount, double *pOutputs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::baselineVector           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nOutputCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutputs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Produce an output row with the most common output (for nominal attributes) and the mean (for continuous attributes). 
<p>

</div>
</div><p>
<a class="anchor" name="aa7070af25cc2abb5f2d84820d2ac34c"></a><!-- doxytag: member="GClasses::GData::centerMeanAtOrigin" ref="aa7070af25cc2abb5f2d84820d2ac34c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::centerMeanAtOrigin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shifts the data such that the mean occurs at the origin. 
<p>

</div>
</div><p>
<a class="anchor" name="e41cd512604b43e8b592ca138c252e36"></a><!-- doxytag: member="GClasses::GData::centroid" ref="e41cd512604b43e8b592ca138c252e36" args="(double *pOutCentroid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::centroid           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutCentroid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the arithmetic means of all attributes. 
<p>

</div>
</div><p>
<a class="anchor" name="5d7ff2bdf2a47e2954542621b6c78a69"></a><!-- doxytag: member="GClasses::GData::cholesky" ref="5d7ff2bdf2a47e2954542621b6c78a69" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::cholesky           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This computes the square root of this matrix. (If you take the matrix that this returns and multiply it by its transpose, you should get the original dataset again.) Behavior is undefined if there are nominal attributes. If this matrix is not positive definate, it will throw an exception. 
<p>

</div>
</div><p>
<a class="anchor" name="1c25758106b0962d17a7da4f97ae781a"></a><!-- doxytag: member="GClasses::GData::clone" ref="1c25758106b0962d17a7da4f97ae781a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::clone           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes a copy of this dataset. 
<p>

</div>
</div><p>
<a class="anchor" name="77f9f64f7ca8a503b4e06f873e9fa0ea"></a><!-- doxytag: member="GClasses::GData::col" ref="77f9f64f7ca8a503b4e06f873e9fa0ea" args="(int index, double *pOutVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::col           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutVector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the specified column into pOutVector. 
<p>

</div>
</div><p>
<a class="anchor" name="d75aa0cfef8e4c5f6c74a12123fa4ce1"></a><!-- doxytag: member="GClasses::GData::cols" ref="d75aa0cfef8e4c5f6c74a12123fa4ce1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GClasses::GData::cols           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of columns in the dataset. 
<p>

</div>
</div><p>
<a class="anchor" name="bd9ba3212afaf6b4e469190fbb272945"></a><!-- doxytag: member="GClasses::GData::copy" ref="bd9ba3212afaf6b4e469190fbb272945" args="(GData *pThat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::copy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pThat</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies all the data from pThat. (Just references the same relation). 
<p>

</div>
</div><p>
<a class="anchor" name="ecae98ffcde0865b051ba323d1222fd4"></a><!-- doxytag: member="GClasses::GData::copyColumns" ref="ecae98ffcde0865b051ba323d1222fd4" args="(int nDestStartColumn, GData *pSource, int nSourceStartColumn, int nColumnCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::copyColumns           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDestStartColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSourceStartColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nColumnCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the specified block of columns from pSource to this dataset. pSource must have the same number of rows as this dataset. 
<p>

</div>
</div><p>
<a class="anchor" name="d5e6425aaa1f56f15e01ad2741d6c64a"></a><!-- doxytag: member="GClasses::GData::copyRow" ref="d5e6425aaa1f56f15e01ad2741d6c64a" args="(const double *pRow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::copyRow           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pRow</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the row to the data set. 
<p>

</div>
</div><p>
<a class="anchor" name="bae1ea54269fcb9d3c3d844076a7c95e"></a><!-- doxytag: member="GClasses::GData::countPrincipalComponents" ref="bae1ea54269fcb9d3c3d844076a7c95e" args="(double d, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GClasses::GData::countPrincipalComponents           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the minimum number of principal components necessary so that less than the specified portion of the deviation in the data is unaccounted for. (For example, if the data projected onto the first 3 principal components contains 90 percent of the deviation that the original data contains, then if you pass the value 0.1 to this method, it will return 3.). 
<p>

</div>
</div><p>
<a class="anchor" name="b9a77d96c3583a0e7116ea06c9b11b6e"></a><!-- doxytag: member="GClasses::GData::countValue" ref="b9a77d96c3583a0e7116ea06c9b11b6e" args="(int attribute, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GClasses::GData::countValue           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of ocurrences of the specified value in the specified attribute. 
<p>

</div>
</div><p>
<a class="anchor" name="9885c08e02cb6df1364f8ed9b20f76f1"></a><!-- doxytag: member="GClasses::GData::covariance" ref="9885c08e02cb6df1364f8ed9b20f76f1" args="(int nAttr1, double dMean1, int nAttr2, double dMean2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::covariance           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dMean1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dMean2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the covariance between two attributes. 
<p>

</div>
</div><p>
<a class="anchor" name="af392277b698a2df79298d2185155c15"></a><!-- doxytag: member="GClasses::GData::covarianceMatrix" ref="af392277b698a2df79298d2185155c15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::covarianceMatrix           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the covariance matrix of the data. 
<p>

</div>
</div><p>
<a class="anchor" name="af6a18854b83dfcf104c7922271db72f"></a><!-- doxytag: member="GClasses::GData::deleteColumn" ref="af6a18854b83dfcf104c7922271db72f" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::deleteColumn           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes a column. 
<p>

</div>
</div><p>
<a class="anchor" name="8afb2fd7d49e54dd0953597e8291f085"></a><!-- doxytag: member="GClasses::GData::deleteRow" ref="8afb2fd7d49e54dd0953597e8291f085" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::deleteRow           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the specified row with the last row, and then deletes it. 
<p>

</div>
</div><p>
<a class="anchor" name="d21ce9f147302613abaa4a2327229bf7"></a><!-- doxytag: member="GClasses::GData::deleteRowPreserveOrder" ref="d21ce9f147302613abaa4a2327229bf7" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::deleteRowPreserveOrder           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the specified row and shifts everything after it up one slot. 
<p>

</div>
</div><p>
<a class="anchor" name="d7a245c771093352f275f0f69cf0e3c1"></a><!-- doxytag: member="GClasses::GData::determinant" ref="d7a245c771093352f275f0f69cf0e3c1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::determinant           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the determinant of this matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="d5f9d47417117e4e5096d2263e8451d6"></a><!-- doxytag: member="GClasses::GData::determinantHelper" ref="d5f9d47417117e4e5096d2263e8451d6" args="(int nEndRow, int *pColumnList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::determinantHelper           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nEndRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pColumnList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="84a7b079dbae340a1c83d4b87d2079cf"></a><!-- doxytag: member="GClasses::GData::dihedralCorrelation" ref="84a7b079dbae340a1c83d4b87d2079cf" args="(GData *pThat, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::dihedralCorrelation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pThat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the cosine of the dihedral angle between this subspace and pThat subspace. 
<p>

</div>
</div><p>
<a class="anchor" name="b81698323e75c023cfd8de4804290963"></a><!-- doxytag: member="GClasses::GData::eigenValue" ref="b81698323e75c023cfd8de4804290963" args="(const double *pMean, const double *pEigenVector, int dims, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::eigenValue           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pEigenVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
After you compute the principal component, you can call this to obtain the eigenvalue that corresponds to that principal component vector (eigenvector). 
<p>

</div>
</div><p>
<a class="anchor" name="dbe75d8d17e5695eaac940980ca5a708"></a><!-- doxytag: member="GClasses::GData::eigenValue" ref="dbe75d8d17e5695eaac940980ca5a708" args="(const double *pEigenVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::eigenValue           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pEigenVector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the eigenvalue that corresponds to the specified eigenvector of this matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="abf01d008a38ae76bf53e58aa71da576"></a><!-- doxytag: member="GClasses::GData::eigenVector" ref="abf01d008a38ae76bf53e58aa71da576" args="(double eigenvalue, double *pOutVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::eigenVector           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>eigenvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutVector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the eigenvector that corresponds to the specified eigenvalue of this matrix. Note that this method trashes this matrix, so make a copy first if you care. 
<p>

</div>
</div><p>
<a class="anchor" name="ef8daeab02484fd2d56b956f9ad73d27"></a><!-- doxytag: member="GClasses::GData::eigs" ref="ef8daeab02484fd2d56b956f9ad73d27" args="(int nCount, double *pEigenVals, GRand *pRand, bool mostSignificant)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::eigs           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pEigenVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>mostSignificant</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes nCount eigenvectors and the corresponding eigenvalues using the power method. (This method is only accurate if a small number of eigenvalues/vectors are needed.) If mostSignificant is true, the largest eigenvalues are found. If mostSignificant is false, the smallest eigenvalues are found. 
<p>

</div>
</div><p>
<a class="anchor" name="df366689e89e87e22d998bb4ee1463ad"></a><!-- doxytag: member="GClasses::GData::ensureDataHasNoMissingNominals" ref="df366689e89e87e22d998bb4ee1463ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::ensureDataHasNoMissingNominals           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Throws an exception if this data contains any missing values in a nominal attribute. 
<p>

</div>
</div><p>
<a class="anchor" name="fa2d9e56b41720f51444d0d33af35018"></a><!-- doxytag: member="GClasses::GData::ensureDataHasNoMissingReals" ref="fa2d9e56b41720f51444d0d33af35018" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::ensureDataHasNoMissingReals           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Throws an exception if this data contains any missing values in a continuous attribute. 
<p>

</div>
</div><p>
<a class="anchor" name="1ce5c716e389fe0419595096264fb5b9"></a><!-- doxytag: member="GClasses::GData::entropy" ref="1ce5c716e389fe0419595096264fb5b9" args="(int nColumn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::entropy           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nColumn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Measures the entropy of the specified attribute. 
<p>

</div>
</div><p>
<a class="anchor" name="279731629d5f14684d49e652692a311a"></a><!-- doxytag: member="GClasses::GData::fixNans" ref="279731629d5f14684d49e652692a311a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::fixNans           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces any occurrences of NAN in the matrix with the corresponding values from an identity matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="52fac7585adc59fdbe9713a320273f46"></a><!-- doxytag: member="GClasses::GData::flush" ref="52fac7585adc59fdbe9713a320273f46" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::flush           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes all the data. 
<p>

</div>
</div><p>
<a class="anchor" name="43b13c021bfe74b1e532cc0aa8e38129"></a><!-- doxytag: member="GClasses::GData::fromVector" ref="43b13c021bfe74b1e532cc0aa8e38129" args="(const double *pVector, size_t nRows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::fromVector           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nRows</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the data from pVector over this dataset. nRows specifies the number of rows of data in pVector. 
<p>

</div>
</div><p>
<a class="anchor" name="2851185a319827c139d09d675f9e6408"></a><!-- doxytag: member="GClasses::GData::gaussianElimination" ref="2851185a319827c139d09d675f9e6408" args="(double *pVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GClasses::GData::gaussianElimination           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes y in the equation M*y=x (or y=M^(-1)x), where M is this dataset, which must be a square matrix, and x is pVector as passed in, and y is pVector after the call. If there are multiple solutions, it finds the one for which all the variables in the null-space have a value of 1. If there are no solutions, it returns false. Note that this method trashes this dataset (so make a copy first if you care). 
<p>

</div>
</div><p>
<a class="anchor" name="6f20b0c5dc0b824d139895926412b4b7"></a><!-- doxytag: member="GClasses::GData::heap" ref="6f20b0c5dc0b824d139895926412b4b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a>* GClasses::GData::heap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the heap used to allocate rows for this dataset. 
<p>

</div>
</div><p>
<a class="anchor" name="23031cea0cf4067dfa4d0783bbab3b3b"></a><!-- doxytag: member="GClasses::GData::inPlaceSquareTranspose" ref="23031cea0cf4067dfa4d0783bbab3b3b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::inPlaceSquareTranspose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cf71982509515eeb03f6eb177b07bca1"></a><!-- doxytag: member="GClasses::GData::isAttrHomogenous" ref="cf71982509515eeb03f6eb177b07bca1" args="(int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GClasses::GData::isAttrHomogenous           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true iff the specified attribute contains homogenous values. (Unknowns are counted as homogenous with anything). 
<p>

</div>
</div><p>
<a class="anchor" name="c1278fda726094c1c731449341c9caf7"></a><!-- doxytag: member="GClasses::GData::kabsch" ref="c1278fda726094c1c731449341c9caf7" args="(GData *pA, GData *pB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::kabsch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This computes K=kabsch(A,B), such that K is an n-by-n matrix, where n is pA-&gt;<a class="el" href="class_g_classes_1_1_g_data.html#d75aa0cfef8e4c5f6c74a12123fa4ce1" title="Returns the number of columns in the dataset.">cols()</a>. K is the optimal orthonormal rotation matrix to align A and B, such that A(K^T) minimizes sum-squared error with B, and BK minimizes sum-squared error with A. (This rotates around the origin, so typically you will want to subtract the centroid from both pA and pB before calling this.). 
<p>

</div>
</div><p>
<a class="anchor" name="b0e51489d293c7d07c65c6f2466bcc3e"></a><!-- doxytag: member="GClasses::GData::leastCorrelatedVector" ref="b0e51489d293c7d07c65c6f2466bcc3e" args="(double *pOut, GData *pThat, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GClasses::GData::leastCorrelatedVector           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pThat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the vector in this subspace that has the greatest distance from its projection into pThat subspace. Returns true if the results are computed. Returns false if the subspaces are so nearly parallel that pOut cannot be computed with accuracy. 
<p>

</div>
</div><p>
<a class="anchor" name="da6914865c5d462586616b3f9c391934"></a><!-- doxytag: member="GClasses::GData::linearCorrelationCoefficient" ref="da6914865c5d462586616b3f9c391934" args="(int attr1, double attr1Origin, int attr2, double attr2Origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::linearCorrelationCoefficient           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>attr1Origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>attr2Origin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the linear coefficient between the two specified attributes. Usually you will want to pass the mean values for attr1Origin and attr2Origin. 
<p>

</div>
</div><p>
<a class="anchor" name="3ee092c8c796d5934eb7e9d9996b75d7"></a><!-- doxytag: member="GClasses::GData::loadArff" ref="3ee092c8c796d5934eb7e9d9996b75d7" args="(const char *szFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::loadArff           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szFilename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads an ARFF file and returns the data. This will throw an exception if there's an error. 
<p>

</div>
</div><p>
<a class="anchor" name="0842c4a9552c35a125da0736100ef573"></a><!-- doxytag: member="GClasses::GData::loadCsv" ref="0842c4a9552c35a125da0736100ef573" args="(const char *szFilename, char separator, bool columnNamesInFirstRow, bool tolerant)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::loadCsv           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>columnNamesInFirstRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>tolerant</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads a file in CSV format. 
<p>

</div>
</div><p>
<a class="anchor" name="c18aa0f642d05c1d2550da1f4015552c"></a><!-- doxytag: member="GClasses::GData::makeIdentity" ref="c18aa0f642d05c1d2550da1f4015552c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::makeIdentity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets this dataset to an identity matrix. (It doesn't change the number of columns or rows. It just stomps over existing values.). 
<p>

</div>
</div><p>
<a class="anchor" name="ad290200e2954da1a2f419d65c1ca66a"></a><!-- doxytag: member="GClasses::GData::mean" ref="ad290200e2954da1a2f419d65c1ca66a" args="(int nAttribute)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::mean           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttribute</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the arithmetic mean of the values in the specified column. 
<p>

</div>
</div><p>
<a class="anchor" name="4128831cacb2e74ffbbc7e12cb4c7549"></a><!-- doxytag: member="GClasses::GData::measureLabelInfo" ref="4128831cacb2e74ffbbc7e12cb4c7549" args="(int labelDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::measureLabelInfo           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>labelDims</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the entropy of the labels (or the deviation if continuous). 
<p>

</div>
</div><p>
<a class="anchor" name="25a5dec09c883d258b01e281a155fbcb"></a><!-- doxytag: member="GClasses::GData::median" ref="25a5dec09c883d258b01e281a155fbcb" args="(int nAttribute)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::median           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttribute</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the median of the values in the specified column. 
<p>

</div>
</div><p>
<a class="anchor" name="b35480e4b2ce76878860c46965b9baed"></a><!-- doxytag: member="GClasses::GData::mergeHoriz" ref="b35480e4b2ce76878860c46965b9baed" args="(GData *pSetA, GData *pSetB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::mergeHoriz           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pSetA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pSetB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merges two datasets side-by-side. The resulting dataset will contain the attributes of both datasets. Both pSetA and pSetB (and the resulting dataset) must have the same number of rows. 
<p>

</div>
</div><p>
<a class="anchor" name="b190f433d841de713b1edd64212c4f6a"></a><!-- doxytag: member="GClasses::GData::mergeVert" ref="b190f433d841de713b1edd64212c4f6a" args="(GData *pData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::mergeVert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pData</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Steals all the rows from pData and adds them to this set. (You still have to delete pData.) Both datasets must have the same number of columns. 
<p>

</div>
</div><p>
<a class="anchor" name="ab6941c932b870db7dae3ce6f90043b6"></a><!-- doxytag: member="GClasses::GData::minAndRange" ref="ab6941c932b870db7dae3ce6f90043b6" args="(int nAttribute, double *pMin, double *pRange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::minAndRange           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pRange</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the min and the range of the values of the specified attribute. 
<p>

</div>
</div><p>
<a class="anchor" name="3f8d4a21a28e22db52c8f6d71767e4df"></a><!-- doxytag: member="GClasses::GData::minAndRangeUnbiased" ref="3f8d4a21a28e22db52c8f6d71767e4df" args="(int nAttribute, double *pMin, double *pRange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::minAndRangeUnbiased           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pRange</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Estimates the actual min and range based on a random sample. 
<p>

</div>
</div><p>
<a class="anchor" name="512fddd1133f0cff58b5a7b18a959fe7"></a><!-- doxytag: member="GClasses::GData::mirrorTriangle" ref="512fddd1133f0cff58b5a7b18a959fe7" args="(bool upperToLower)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::mirrorTriangle           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>upperToLower</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If upperToLower is true, copies the upper triangle of this matrix over the lower triangle If upperToLower is false, copies the lower triangle of this matrix over the upper triangle. 
<p>

</div>
</div><p>
<a class="anchor" name="4f3e1da8966366e52a247d3e043ff126"></a><!-- doxytag: member="GClasses::GData::multiply" ref="4f3e1da8966366e52a247d3e043ff126" args="(GData &amp;a, GData &amp;b, bool transposeA, bool transposeB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::multiply           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>transposeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>transposeB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Matrix multiply. For convenience, you can also specify that neither, one, or both of the inputs are virtually transposed prior to the multiplication. (If you want the results to come out transposed, you can use the equality AB=((B^T)(A^T))^T to figure out how to specify the parameters.). 
<p>

</div>
</div><p>
<a class="anchor" name="9187067dc8bdb66c56fbc86455029e43"></a><!-- doxytag: member="GClasses::GData::multiply" ref="9187067dc8bdb66c56fbc86455029e43" args="(const double *pVectorIn, double *pVectorOut, bool transpose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::multiply           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVectorIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVectorOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>transpose</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplies this matrix by the column vector pVectorIn to get pVectorOut. (If transpose is true, then it multiplies the transpose of this matrix by pVectorIn to get pVectorOut.) pVectorIn should have the same number of elements as columns (or rows if transpose is true) and pVectorOut should have the same number of elements as rows (or cols, if transpose is true.) Note that if transpose is true, it is the same as if pVectorIn is a row vector and you multiply it by this matrix to get pVectorOut. 
<p>

</div>
</div><p>
<a class="anchor" name="2e538733e0b79c8ec550685261f6fe92"></a><!-- doxytag: member="GClasses::GData::multiply" ref="2e538733e0b79c8ec550685261f6fe92" args="(double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::multiply           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scalar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplies every element in the dataset by scalar. Behavior is undefined for nominal columns. 
<p>

</div>
</div><p>
<a class="anchor" name="1a786f3f221a2f7c8f48855a472d8ee5"></a><!-- doxytag: member="GClasses::GData::newRow" ref="1a786f3f221a2f7c8f48855a472d8ee5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* GClasses::GData::newRow           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a new row to the dataset. (The values in the row are not initialized). 
<p>

</div>
</div><p>
<a class="anchor" name="cb1aef66247943db7e0303080616d3bc"></a><!-- doxytag: member="GClasses::GData::newRows" ref="cb1aef66247943db7e0303080616d3bc" args="(size_t nRows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::newRows           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nRows</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds "nRows" uninitialized rows of size "nAttributes" to the data set. 
<p>

</div>
</div><p>
<a class="anchor" name="1a31ee9795f5562ac672213fa4faa670"></a><!-- doxytag: member="GClasses::GData::normalize" ref="1a31ee9795f5562ac672213fa4faa670" args="(double dVal, double dInputMin, double dInputRange, double dOutputMin, double dOutputRange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GData::normalize           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dInputMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dInputRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dOutputMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dOutputRange</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalize a value from the input min and range to the output min and range. 
<p>

</div>
</div><p>
<a class="anchor" name="dd0df3525d45b21328ca4388aa35dbac"></a><!-- doxytag: member="GClasses::GData::normalize" ref="dd0df3525d45b21328ca4388aa35dbac" args="(int nAttribute, double dInputMin, double dInputRange, double dOutputMin, double dOutputRange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::normalize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dInputMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dInputRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dOutputMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dOutputRange</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalizes the specified attribute values. 
<p>

</div>
</div><p>
<a class="anchor" name="3fea5d763706a9529656d9ee9e801e4d"></a><!-- doxytag: member="GClasses::GData::operator[]" ref="3fea5d763706a9529656d9ee9e801e4d" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* GClasses::GData::operator[]           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the specified row. 
<p>

</div>
</div><p>
<a class="anchor" name="34cc4df701b28b65fafd371fd3ad0d20"></a><!-- doxytag: member="GClasses::GData::pairedTTest" ref="34cc4df701b28b65fafd371fd3ad0d20" args="(int *pOutV, double *pOutT, int attr1, int attr2, bool normalize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::pairedTTest           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pOutV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>normalize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a paired T-Test with data from the two specified attributes. pOutV will hold the degrees of freedom. pOutT will hold the T-value. You can use <a class="el" href="class_g_classes_1_1_g_math.html#e19ea9621f599142d2ebb3ad0ff37404" title="Computes the p-value from the degrees of freedom, and the t-value obtained from a...">GMath::tTestAlphaValue</a> to convert these to a P-value. 
<p>

</div>
</div><p>
<a class="anchor" name="0d3567afb8631eb587c01230a4c56129"></a><!-- doxytag: member="GClasses::GData::parseArff" ref="0d3567afb8631eb587c01230a4c56129" args="(const char *szFile, size_t nLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::parseArff           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses an ARFF file and returns the data. This will throw an exception if there's an error. 
<p>

</div>
</div><p>
<a class="anchor" name="3b44b62453226a035403be077f949006"></a><!-- doxytag: member="GClasses::GData::parseCsv" ref="3b44b62453226a035403be077f949006" args="(const char *pFile, size_t len, char separator, bool columnNamesInFirstRow, bool tolerant=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::parseCsv           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>columnNamesInFirstRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>tolerant</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Imports data from a text file. Determines the meta-data automatically. Note: This method does not support Mac line-endings. You should first replace all '' with '<br>
' if your data comes from a Mac. As a special case, if separator is '', then it assumes data elements are separated by any number of whitespace characters, that element values themselves contain no whitespace, and that there are no missing elements. (This is the case when you save a Matlab matrix to an ascii file.). 
<p>

</div>
</div><p>
<a class="anchor" name="97a7f75513c28daef372d6e74bdc1c7c"></a><!-- doxytag: member="GClasses::GData::parseDataRow" ref="97a7f75513c28daef372d6e74bdc1c7c" args="(GArffRelation *pRelation, GData *pData, const char *szFile, size_t nLen, int nLine)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GData::parseDataRow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_arff_relation.html">GArffRelation</a> *&nbsp;</td>
          <td class="paramname"> <em>pRelation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nLine</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b0a8f97364885251437b1fa1232f8b67"></a><!-- doxytag: member="GClasses::GData::principalComponent" ref="b0a8f97364885251437b1fa1232f8b67" args="(double *pOutVector, int dims, const double *pMean, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::principalComponent           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is an efficient algorithm for iteratively computing the principal component vector (the eigenvector of the covariance matrix) of the data. See "EM Algorithms for PCA and SPCA" by Sam Roweis, 1998 NIPS. nIterations should be a small constant. 20 seems work well for most applications. (To compute the next principal component, call RemoveComponent, then call this again.). 
<p>

</div>
</div><p>
<a class="anchor" name="50a542d0f229a3780f7e8657cafc36ab"></a><!-- doxytag: member="GClasses::GData::principalComponentAboutOrigin" ref="50a542d0f229a3780f7e8657cafc36ab" args="(double *pOutVector, int dims, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::principalComponentAboutOrigin           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the first principal component assuming the mean is already subtracted out of the data. 
<p>

</div>
</div><p>
<a class="anchor" name="01c735e82a5f9bae229b28f80f9e3559"></a><!-- doxytag: member="GClasses::GData::principalComponentIgnoreUnknowns" ref="01c735e82a5f9bae229b28f80f9e3559" args="(double *pOutVector, int dims, const double *pMean, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::principalComponentIgnoreUnknowns           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes principal components, while ignoring missing values. 
<p>

</div>
</div><p>
<a class="anchor" name="2621fb5460f84216bb382f0bf7979ad6"></a><!-- doxytag: member="GClasses::GData::print" ref="2621fb5460f84216bb382f0bf7979ad6" args="(std::ostream &amp;stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::print           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the data to the specified stream. 
<p>

</div>
</div><p>
<a class="anchor" name="f7645c929afb9621b326dc6baabd7cb9"></a><!-- doxytag: member="GClasses::GData::project" ref="f7645c929afb9621b326dc6baabd7cb9" args="(double *pDest, const double *pPoint, const double *pOrigin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::project           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pOrigin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Projects pPoint onto this hyperplane (where each row defines one of the orthonormal basis vectors of this hyperplane). 
<p>

</div>
</div><p>
<a class="anchor" name="d4d13175c82a71e7d9c4c821ceb2f74f"></a><!-- doxytag: member="GClasses::GData::project" ref="d4d13175c82a71e7d9c4c821ceb2f74f" args="(double *pDest, const double *pPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::project           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pPoint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Projects pPoint onto this hyperplane (where each row defines one of the orthonormal basis vectors of this hyperplane) This computes (A^T)Ap, where A is this matrix, and p is pPoint. 
<p>

</div>
</div><p>
<a class="anchor" name="d9ccdd23640cc90ee34535a37f2ac410"></a><!-- doxytag: member="GClasses::GData::pseudoInverse" ref="d9ccdd23640cc90ee34535a37f2ac410" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::pseudoInverse           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the Moore-Penrose pseudoinverse of this matrix (using the SVD method). You are responsible to delete the matrix this returns. 
<p>

</div>
</div><p>
<a class="anchor" name="7db046b1dfb8b83d87f868a2ee880583"></a><!-- doxytag: member="GClasses::GData::randomlyReplaceMissingValues" ref="7db046b1dfb8b83d87f868a2ee880583" args="(int nAttr, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::randomlyReplaceMissingValues           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces all missing values by copying a randomly selected non-missing value in the same attribute (This messes up the order of the rows because it uses sorting to find the missing values, so you should probably call Shuffle() when you're done calling this method.). 
<p>

</div>
</div><p>
<a class="anchor" name="7809945ef1f0dfd13f9d9d91fb68f3ef"></a><!-- doxytag: member="GClasses::GData::relation" ref="7809945ef1f0dfd13f9d9d91fb68f3ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a>&amp; GClasses::GData::relation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a relation object, which holds meta-data about the attributes (columns). 
<p>

</div>
</div><p>
<a class="anchor" name="0553e6ba1aeabbe7d80ec9f4f4e7dee7"></a><!-- doxytag: member="GClasses::GData::releaseAllRows" ref="0553e6ba1aeabbe7d80ec9f4f4e7dee7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::releaseAllRows           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Abandons (leaks) all the rows of data. 
<p>

</div>
</div><p>
<a class="anchor" name="879bf4be4edac53d6bee85e1b4d395e6"></a><!-- doxytag: member="GClasses::GData::releaseRow" ref="879bf4be4edac53d6bee85e1b4d395e6" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* GClasses::GData::releaseRow           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the specified row with the last row, and then releases it from the dataset. If this dataset does not have its own heap, then you must delete the row this returns. 
<p>

</div>
</div><p>
<a class="anchor" name="443deea99f259889700f88edd793d9f6"></a><!-- doxytag: member="GClasses::GData::releaseRowPreserveOrder" ref="443deea99f259889700f88edd793d9f6" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* GClasses::GData::releaseRowPreserveOrder           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases the specified row from the dataset and shifts everything after it up one slot. If this dataset does not have its own heap, then you must delete the row this returns. 
<p>

</div>
</div><p>
<a class="anchor" name="9311947fa00ec06850cefa4fddb136e9"></a><!-- doxytag: member="GClasses::GData::removeComponent" ref="9311947fa00ec06850cefa4fddb136e9" args="(const double *pMean, const double *pComponent, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::removeComponent           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pComponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the component specified by pComponent from the data. (pComponent should already be normalized.) This might be useful, for example, to remove the first principal component from the data so you can then proceed to compute the second principal component, and so forth. 
<p>

</div>
</div><p>
<a class="anchor" name="19faad94e458e3f4015ef32256da95e3"></a><!-- doxytag: member="GClasses::GData::removeComponentAboutOrigin" ref="19faad94e458e3f4015ef32256da95e3" args="(const double *pComponent, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::removeComponentAboutOrigin           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pComponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the specified component assuming the mean is zero. 
<p>

</div>
</div><p>
<a class="anchor" name="b43ec600d08405e05b2949f54d132f3f"></a><!-- doxytag: member="GClasses::GData::replaceRow" ref="b43ec600d08405e05b2949f54d132f3f" args="(size_t nIndex, double *pRow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* GClasses::GData::replaceRow           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pRow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps pRow with the row at nIndex. You're responsible to delete the row this returns. 
<p>

</div>
</div><p>
<a class="anchor" name="abd3a7ab24db6a0faf054d225b206b30"></a><!-- doxytag: member="GClasses::GData::reserve" ref="abd3a7ab24db6a0faf054d225b206b30" args="(size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::reserve           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates space for the specified number of patters (to avoid superfluous resizing). 
<p>

</div>
</div><p>
<a class="anchor" name="7c221e7aec118a7d7f707d0de733d872"></a><!-- doxytag: member="GClasses::GData::reverseRows" ref="7c221e7aec118a7d7f707d0de733d872" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::reverseRows           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reverses the row order. 
<p>

</div>
</div><p>
<a class="anchor" name="040031eeca3825a4bf485acba62168d9"></a><!-- doxytag: member="GClasses::GData::row" ref="040031eeca3825a4bf485acba62168d9" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* GClasses::GData::row           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the specified row. 
<p>

</div>
</div><p>
<a class="anchor" name="2ec481f296ab65163e30d51513f25e6c"></a><!-- doxytag: member="GClasses::GData::rows" ref="2ec481f296ab65163e30d51513f25e6c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GClasses::GData::rows           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of rows in the dataset. 
<p>

</div>
</div><p>
<a class="anchor" name="e05530098714f10b8ffa6d12107d3f74"></a><!-- doxytag: member="GClasses::GData::saveArff" ref="e05530098714f10b8ffa6d12107d3f74" args="(const char *szFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::saveArff           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szFilename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the dataset to a file in ARFF format. 
<p>

</div>
</div><p>
<a class="anchor" name="c654d807bdffbdee3b68b5e44e0637dd"></a><!-- doxytag: member="GClasses::GData::setAll" ref="c654d807bdffbdee3b68b5e44e0637dd" args="(double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::setAll           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets all elements in this dataset to the specified value. 
<p>

</div>
</div><p>
<a class="anchor" name="e9c148a23066815fd0a86a9fcb67fcd6"></a><!-- doxytag: member="GClasses::GData::setCol" ref="e9c148a23066815fd0a86a9fcb67fcd6" args="(int index, const double *pVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::setCol           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies pVector over the specified column. 
<p>

</div>
</div><p>
<a class="anchor" name="01acd8108435a42c67f693b4e5b31a5c"></a><!-- doxytag: member="GClasses::GData::setRelation" ref="01acd8108435a42c67f693b4e5b31a5c" args="(sp_relation &amp;pRelation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::setRelation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pRelation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the relation for this dataset. 
<p>

</div>
</div><p>
<a class="anchor" name="3403568b2750bb2f315fe0b3339a0a61"></a><!-- doxytag: member="GClasses::GData::shuffle" ref="3403568b2750bb2f315fe0b3339a0a61" args="(GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::shuffle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Randomizes the order of the rows. 
<p>

</div>
</div><p>
<a class="anchor" name="b253922d7acbad99853d0678a9c170a4"></a><!-- doxytag: member="GClasses::GData::shuffle2" ref="b253922d7acbad99853d0678a9c170a4" args="(GRand *pRand, GData &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::shuffle2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shuffles the order of the rows. Also shuffles the rows in "other" in the same way, such that corresponding rows are preserved. 
<p>

</div>
</div><p>
<a class="anchor" name="eb8dfcd9491c53e6dfcf1843ec775d88"></a><!-- doxytag: member="GClasses::GData::shuffleLikeCards" ref="eb8dfcd9491c53e6dfcf1843ec775d88" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::shuffleLikeCards           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is an inferior way to shuffle the data. 
<p>

</div>
</div><p>
<a class="anchor" name="a14785165dfd06f14a36944cc575011c"></a><!-- doxytag: member="GClasses::GData::singularValueDecomposition" ref="a14785165dfd06f14a36944cc575011c" args="(GData **ppU, double **ppDiag, GData **ppV, bool throwIfNoConverge=false, int maxIters=80)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::singularValueDecomposition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> **&nbsp;</td>
          <td class="paramname"> <em>ppU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>ppDiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> **&nbsp;</td>
          <td class="paramname"> <em>ppV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>throwIfNoConverge</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxIters</em> = <code>80</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs SVD on A, where A is this m-by-n matrix. *ppU will be set to an m-by-m matrix where the columns are the eigenvectors of A(A^T). *ppDiag will be set to an array of n doubles holding the square roots of the corresponding eigenvalues. *ppV will be set to an n-by-n matrix where the rows are the eigenvectors of (A^T)A. You are responsible to delete(*ppU), delete(*ppV), and delete[] *ppDiag. 
<p>

</div>
</div><p>
<a class="anchor" name="0a4c50b66fdea1955a5c7251229e69c6"></a><!-- doxytag: member="GClasses::GData::singularValueDecompositionHelper" ref="0a4c50b66fdea1955a5c7251229e69c6" args="(GData **ppU, double **ppDiag, GData **ppV, bool throwIfNoConverge, int maxIters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::singularValueDecompositionHelper           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> **&nbsp;</td>
          <td class="paramname"> <em>ppU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>ppDiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> **&nbsp;</td>
          <td class="paramname"> <em>ppV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>throwIfNoConverge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxIters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2a6c45c34c45b8361d8fb6a2aac168d8"></a><!-- doxytag: member="GClasses::GData::sort" ref="2a6c45c34c45b8361d8fb6a2aac168d8" args="(CompareFunc &amp;pComparator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompareFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::sort           </td>
          <td>(</td>
          <td class="paramtype">CompareFunc &amp;&nbsp;</td>
          <td class="paramname"> <em>pComparator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts rows according to the specified compare function. (Return true to indicate thate the first row comes before the second row.). 
<p>

</div>
</div><p>
<a class="anchor" name="16a682d8063f84c74b010da458c619d9"></a><!-- doxytag: member="GClasses::GData::sort" ref="16a682d8063f84c74b010da458c619d9" args="(int nDimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::sort           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDimension</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts the data from smallest to largest in the specified dimension. 
<p>

</div>
</div><p>
<a class="anchor" name="1e92f2186659580a645848b5787ec15d"></a><!-- doxytag: member="GClasses::GData::splitByDiscreteValue" ref="1e92f2186659580a645848b5787ec15d" args="(GData *pSingleClass, int nAttr, int nValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::splitByDiscreteValue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pSingleClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves all rows with the specified value in the specified attribute into pSingleClass. 
<p>

</div>
</div><p>
<a class="anchor" name="337e2cad435a263e1d80c0d7e7fc0cd5"></a><!-- doxytag: member="GClasses::GData::splitByPivot" ref="337e2cad435a263e1d80c0d7e7fc0cd5" args="(GData *pGreaterOrEqual, int nAttribute, double dPivot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::splitByPivot           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pGreaterOrEqual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dPivot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Splits this set of data into two sets. Values greater-than-or-equal-to dPivot stay in this data set. Values less than dPivot go into pLessThanPivot. 
<p>

</div>
</div><p>
<a class="anchor" name="47c0b3c582fafd9742c60a1ca929c7c8"></a><!-- doxytag: member="GClasses::GData::splitBySize" ref="47c0b3c582fafd9742c60a1ca929c7c8" args="(GData *pOtherData, size_t nOtherRows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::splitBySize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pOtherData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nOtherRows</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the last nOtherRows rows from this data set and puts them in pOtherData. 
<p>

</div>
</div><p>
<a class="anchor" name="c7fad799a9bc665dc9a9d66ca80d0ca7"></a><!-- doxytag: member="GClasses::GData::subtract" ref="c7fad799a9bc665dc9a9d66ca80d0ca7" args="(GData *pThat, bool transpose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::subtract           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pThat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>transpose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Matrix subtract. Subtracts the values in pThat from this. (If transpose is true, subtracts the transpose of pThat from this.) Both datasets must have the same dimensions. Behavior is undefined for nominal columns. 
<p>

</div>
</div><p>
<a class="anchor" name="67b4ee5797d5dc1439f1d573d2422cde"></a><!-- doxytag: member="GClasses::GData::sumSquaredDifference" ref="67b4ee5797d5dc1439f1d573d2422cde" args="(GData &amp;that, bool transpose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::sumSquaredDifference           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>transpose</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the squared distance between this and that. (If transpose is true, computes the difference between this and the transpose of that.). 
<p>

</div>
</div><p>
<a class="anchor" name="bcd1d1ed2f4272c1f9c58c4f2bb1e5be"></a><!-- doxytag: member="GClasses::GData::sumSquaredDiffWithIdentity" ref="bcd1d1ed2f4272c1f9c58c4f2bb1e5be" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::sumSquaredDiffWithIdentity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the sum squared difference between this matrix and an identity matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="67984f3368039d0d1e9ff5887d3c9571"></a><!-- doxytag: member="GClasses::GData::sumSquaredDistance" ref="67984f3368039d0d1e9ff5887d3c9571" args="(const double *pPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::sumSquaredDistance           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pPoint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sum-squared distance between pPoint and all of the points in the dataset. (If pPoint is NULL, it computes the sum-squared distance with the origin.) (Note that this is equal to the sum of all the eigenvalues times the number of dimensions, so you can efficiently compute eigenvalues as the difference in sumSquaredDistance with the mean after removing the corresponding component, and then dividing by the number of dimensions. This is more efficient than calling eigenValue.). 
<p>

</div>
</div><p>
<a class="anchor" name="5448aec5af95c4a7317167b4faa1fd90"></a><!-- doxytag: member="GClasses::GData::swapColumns" ref="5448aec5af95c4a7317167b4faa1fd90" args="(int nAttr1, int nAttr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::swapColumns           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttr2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps two columns. 
<p>

</div>
</div><p>
<a class="anchor" name="7467e46b6901fe6880e19812370e8a8b"></a><!-- doxytag: member="GClasses::GData::swapRows" ref="7467e46b6901fe6880e19812370e8a8b" args="(size_t a, size_t b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::swapRows           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the two specified rows. 
<p>

</div>
</div><p>
<a class="anchor" name="f5787ef975452a5fd762b6cb77cab833"></a><!-- doxytag: member="GClasses::GData::takeRow" ref="f5787ef975452a5fd762b6cb77cab833" args="(double *pRow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::takeRow           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pRow</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an already-allocated row to this dataset. The row must be allocated in the same heap that this dataset uses. (There is no way for this method to verify that, so be careful.). 
<p>

</div>
</div><p>
<a class="anchor" name="5945408aee842ec9a8442e4ead2a574f"></a><!-- doxytag: member="GClasses::GData::test" ref="5945408aee842ec9a8442e4ead2a574f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GData::test           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs unit tests for this class. Throws an exception if there is a failure. 
<p>

</div>
</div><p>
<a class="anchor" name="5db75722761658872985ca9a5b463931"></a><!-- doxytag: member="GClasses::GData::toReducedRowEchelonForm" ref="5db75722761658872985ca9a5b463931" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GClasses::GData::toReducedRowEchelonForm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the matrix to reduced row echelon form. 
<p>

</div>
</div><p>
<a class="anchor" name="d8fa15e3bb45b9aaafd76c472b756d7c"></a><!-- doxytag: member="GClasses::GData::toTwt" ref="d8fa15e3bb45b9aaafd76c472b756d7c" args="(GTwtDoc *pDoc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a>* GClasses::GData::toTwt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_twt_doc.html">GTwtDoc</a> *&nbsp;</td>
          <td class="paramname"> <em>pDoc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes data to a text file in ".twt" format. 
<p>

</div>
</div><p>
<a class="anchor" name="b289f9bc96a6a551730569628c5529c6"></a><!-- doxytag: member="GClasses::GData::toVector" ref="b289f9bc96a6a551730569628c5529c6" args="(double *pVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::toVector           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pVector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies all the data from this dataset into pVector. pVector must be big enough to hold <a class="el" href="class_g_classes_1_1_g_data.html#2ec481f296ab65163e30d51513f25e6c" title="Returns the number of rows in the dataset.">rows()</a> x <a class="el" href="class_g_classes_1_1_g_data.html#d75aa0cfef8e4c5f6c74a12123fa4ce1" title="Returns the number of columns in the dataset.">cols()</a> doubles. 
<p>

</div>
</div><p>
<a class="anchor" name="80052a0c630caa79be8b7eaa7457d519"></a><!-- doxytag: member="GClasses::GData::trace" ref="80052a0c630caa79be8b7eaa7457d519" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::trace           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the sum of the diagonal elements. 
<p>

</div>
</div><p>
<a class="anchor" name="6b9af7ce058444469db0b7227e1228c4"></a><!-- doxytag: member="GClasses::GData::transpose" ref="6b9af7ce058444469db0b7227e1228c4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GData::transpose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a dataset that is this dataset transposed. (All columns in the returned dataset will be continuous.). 
<p>

</div>
</div><p>
<a class="anchor" name="3cd6bc315143a5d96b6bde15a7eba300"></a><!-- doxytag: member="GClasses::GData::variance" ref="3cd6bc315143a5d96b6bde15a7eba300" args="(int nAttr, double mean)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::variance           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>mean</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the average variance of a single attribute. 
<p>

</div>
</div><p>
<a class="anchor" name="67f2713275628a9b0c5763672f89ff5a"></a><!-- doxytag: member="GClasses::GData::weightedPrincipalComponent" ref="67f2713275628a9b0c5763672f89ff5a" args="(double *pOutVector, int dims, const double *pMean, const double *pWeights, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GData::weightedPrincipalComponent           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the first principal component of the data with each row weighted according to the vector pWeights. (pWeights must have an element for each row.). 
<p>

</div>
</div><p>
<a class="anchor" name="924e656e95432de6d081bf5210d42ccb"></a><!-- doxytag: member="GClasses::GData::wilcoxonSignedRanksTest" ref="924e656e95432de6d081bf5210d42ccb" args="(int attr1, int attr2, double tolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GData::wilcoxonSignedRanksTest           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs the Wilcoxon signed ranks test from the two specified attributes and returns the T-value. If two values are closer than tolerance, they are considered to be equal. 
<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="48e28e6df1bbed0b20656e178f2c964b"></a><!-- doxytag: member="GClasses::GData::m_pHeap" ref="48e28e6df1bbed0b20656e178f2c964b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a>* <a class="el" href="class_g_classes_1_1_g_data.html#48e28e6df1bbed0b20656e178f2c964b">GClasses::GData::m_pHeap</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7f259cdc99e7bf1b4b43f308edaef00b"></a><!-- doxytag: member="GClasses::GData::m_pRelation" ref="7f259cdc99e7bf1b4b43f308edaef00b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> <a class="el" href="class_g_classes_1_1_g_data.html#7f259cdc99e7bf1b4b43f308edaef00b">GClasses::GData::m_pRelation</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="328eb6db165c5a9c4b08939f9b1eb416"></a><!-- doxytag: member="GClasses::GData::m_rows" ref="328eb6db165c5a9c4b08939f9b1eb416" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double*&gt; <a class="el" href="class_g_classes_1_1_g_data.html#328eb6db165c5a9c4b08939f9b1eb416">GClasses::GData::m_rows</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Nov 2 14:18:23 2010 for GClasses by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
