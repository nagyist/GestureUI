<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>GClasses: GClasses Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>GClasses Namespace Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_function.html">GActivationFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The base class for activation functions. Typically, this are sigmoid-shaped functions used to "squash" the output of a network node. These are typically used in conjunction with the <a class="el" href="class_g_classes_1_1_g_neural_net.html" title="An artificial neural network.">GNeuralNet</a> class.  <a href="class_g_classes_1_1_g_activation_function.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_logistic.html">GActivationLogistic</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The logistic activation function.  <a href="class_g_classes_1_1_g_activation_logistic.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_arc_tan.html">GActivationArcTan</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The arctan activation function.  <a href="class_g_classes_1_1_g_activation_arc_tan.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_tan_h.html">GActivationTanH</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The hyperbolic tangent activation function.  <a href="class_g_classes_1_1_g_activation_tan_h.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_algebraic.html">GActivationAlgebraic</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The hyperbolic tangent activation function.  <a href="class_g_classes_1_1_g_activation_algebraic.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_identity.html">GActivationIdentity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this function when you do not want to squash the net. For example, using this activation function with a network that has no hidden layers makes a perceptron model. Also, it is common to use this activation function on the output layer for regression problems.  <a href="class_g_classes_1_1_g_activation_identity.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_bend.html">GActivationBend</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This provides an alternative to using <a class="el" href="class_g_classes_1_1_g_activation_identity.html" title="Use this function when you do not want to squash the net. For example, using this...">GActivationIdentity</a> on the output layer for regression problems. It may add more power because it is non-linear, but like the identity function, its co-domain is the same as its domain.  <a href="class_g_classes_1_1_g_activation_bend.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_bi_dir.html">GActivationBiDir</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an output-layer activation function shaped like a sigmoid, but with both a co-domain and domain that spans the continuous values.  <a href="class_g_classes_1_1_g_activation_bi_dir.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_piecewise.html">GActivationPiecewise</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an experimental activation function intended to reduce the required computation involved in inverting neural networks.  <a href="class_g_classes_1_1_g_activation_piecewise.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_app.html">GApp</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains some generally useful functions for launching applications.  <a href="class_g_classes_1_1_g_app.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_signal_handler.html">GSignalHandler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporarily handles certain signals. (When this object is destroyed, it puts all the signal handlers back the way they were.) Periodically call "check" to see if a signal has occurred.  <a href="class_g_classes_1_1_g_signal_handler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_passive_console.html">GPassiveConsole</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides a non-blocking method for reading characters from stdin. (If there are no characters ready in stdin, it immediately returns ''.) The constructor sets flags on the console so that it passes characters to the stream immediately (instead of when Enter is pressed), and so that it doesn't echo the keys, and it makes stdin non-blocking. The destructor puts all those things back the way they were.  <a href="class_g_classes_1_1_g_passive_console.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_arg_reader.html">GArgReader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses command-line args and provides methods to conveniently process them.  <a href="class_g_classes_1_1_g_arg_reader.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bayesian_network_node.html">GBayesianNetworkNode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class for all nodes in a Bayesian network. Classes that inherit from this class must implement three pure virtual methods. Note that the <a class="el" href="class_g_classes_1_1_g_univariate_distribution.html" title="This is the base class for univariate distributions.">GUnivariateDistribution</a> class has an IsDiscrete and an IsSupported method, so if your class wraps a <a class="el" href="class_g_classes_1_1_g_univariate_distribution.html" title="This is the base class for univariate distributions.">GUnivariateDistribution</a> then two of them are taken care of for you. In order to implement ComputeLogLikelihood, your class will probably need references to its parent nodes so that it can obtain their values to use as parameters for its distribution. You can implement your network structure however you like. When you have your network set up, you're ready to use MCMC to infer values for the network. To do this, just create a loop that calls Sample on each node in the network, and the whole network should eventually converge to good values. (Also, you need to make <a class="el" href="class_g_classes_1_1_g_bayesian_network_child_iterator.html" title="Iterates through all the children of the specified node in a Bayesian network.">GBayesianNetworkChildIterator</a> work, which I haven't worked out yet.).  <a href="class_g_classes_1_1_g_bayesian_network_node.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bayesian_network_child_iterator.html">GBayesianNetworkChildIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates through all the children of the specified node in a Bayesian network.  <a href="class_g_classes_1_1_g_bayesian_network_child_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bits.html">GBits</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains various functions for bit analysis.  <a href="class_g_classes_1_1_g_bits.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bit_table.html">GBitTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a table of bits.  <a href="class_g_classes_1_1_g_bit_table.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_clusterer.html">GClusterer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The base class for clustering algorithms. Classes that inherit from this class must implement a method named "cluster" which performs clustering, and a method named "whichCluster" which reports which cluster the specified row is determined to be a member of.  <a href="class_g_classes_1_1_g_clusterer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_agglomerative_clusterer.html">GAgglomerativeClusterer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This merges each cluster with its closest neighbor. (The distance between clusters is computed as the distance between the closest members of the clusters times (n^b), where n is the total number of points from both clusters, and b is a balancing factor.  <a href="class_g_classes_1_1_g_agglomerative_clusterer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_agglomerative_transducer.html">GAgglomerativeTransducer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a semi-supervised agglomerative clusterer. It can only handle one output, and it must be nominal. All inputs must be continuous. Also, it assumes that all output values are represented in the training set.  <a href="class_g_classes_1_1_g_agglomerative_transducer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_k_means.html">GKMeans</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of the K-means clustering algorithm.  <a href="class_g_classes_1_1_g_k_means.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_k_medoids.html">GKMedoids</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of the K-medoids clustering algorithm.  <a href="class_g_classes_1_1_g_k_medoids.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_graph_cut_transducer.html">GGraphCutTransducer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_relation.html">GRelation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds the metadata for a dataset, including which attributes are continuous or nominal, and how many values each nominal attribute supports.  <a href="class_g_classes_1_1_g_relation.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_uniform_relation.html">GUniformRelation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A relation with a minimal memory footprint that assumes all attributes are continuous, or all of them are nominal and have the same number of possible values.  <a href="class_g_classes_1_1_g_uniform_relation.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_mixed_relation.html">GMixedRelation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_arff_attribute.html">GArffAttribute</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_arff_relation.html">GArffRelation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ARFF = Attribute-Relation File Format. This stores richer information than <a class="el" href="class_g_classes_1_1_g_relation.html" title="Holds the metadata for a dataset, including which attributes are continuous or nominal...">GRelation</a>. This includes a name, a name for each attribute, and names for each supported nominal value.  <a href="class_g_classes_1_1_g_arff_relation.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a matrix or a database table. Elements can be discrete or continuous. References a <a class="el" href="class_g_classes_1_1_g_relation.html" title="Holds the metadata for a dataset, including which attributes are continuous or nominal...">GRelation</a> object, which stores the meta-information about each column.  <a href="class_g_classes_1_1_g_data.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_release_data_holder.html">GReleaseDataHolder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a special holder that guarantees the data set will release all of its data before it is deleted.  <a href="class_g_classes_1_1_g_release_data_holder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_data_array.html">GDataArray</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_decision_tree.html">GDecisionTree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an efficient learning algorithm. It divides on the attributes that reduce entropy the most, or alternatively can make random divisions.  <a href="class_g_classes_1_1_g_decision_tree.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_mean_margins_tree.html">GMeanMarginsTree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="class_g_classes_1_1_g_mean_margins_tree.html" title="A GMeanMarginsTree is similar a DecisionTree, except it divides as follows: It finds...">GMeanMarginsTree</a> is similar a DecisionTree, except it divides as follows: It finds the mean and principle component of the output vectors. It divides all the vectors into two groups, one that has a positive dot-product with the principle component (after subtracting the mean) and one that has a negative dot-product with the principle component (after subtracting the mean). Next it finds the average input vector for each of the two groups. Then it finds the mean and principle component of those two vectors. The dividing criteria for this node is to subtract the mean and then see whether the dot-product with the principle component is positive or negative.  <a href="class_g_classes_1_1_g_mean_margins_tree.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_distribution.html">GDistribution</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_univariate_distribution.html">GUnivariateDistribution</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class for univariate distributions.  <a href="class_g_classes_1_1_g_univariate_distribution.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_categorical_distribution.html">GCategoricalDistribution</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a distribution that specifies a probability for each value in a set of nominal values.  <a href="class_g_classes_1_1_g_categorical_distribution.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_normal_distribution.html">GNormalDistribution</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the Normal (a.k.a. Gaussian) distribution.  <a href="class_g_classes_1_1_g_normal_distribution.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_uniform_distribution.html">GUniformDistribution</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a continuous uniform distribution.  <a href="class_g_classes_1_1_g_uniform_distribution.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_poisson_distribution.html">GPoissonDistribution</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Poisson distribution.  <a href="class_g_classes_1_1_g_poisson_distribution.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_gamma_distribution.html">GGammaDistribution</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Gamma distribution.  <a href="class_g_classes_1_1_g_gamma_distribution.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_inverse_gamma_distribution.html">GInverseGammaDistribution</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The inverse Gamma distribution.  <a href="class_g_classes_1_1_g_inverse_gamma_distribution.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_beta_distribution.html">GBetaDistribution</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Beta distribution.  <a href="class_g_classes_1_1_g_beta_distribution.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_soft_impulse_distribution.html">GSoftImpulseDistribution</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_multivariate_normal_distribution.html">GMultivariateNormalDistribution</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A multivariate Normal distribution. It can compute the likelihood of a specified vector, and can also generate random vectors from the distribution.  <a href="class_g_classes_1_1_g_multivariate_normal_distribution.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bag.html">GBag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BAG stands for bootstrap aggregator. It represents an ensemble of voting modelers. Each model is trained with a slightly different training set, which is produced by drawing randomly from the original training set with replacement until we have a new training set of the same size. Each model is given equal weight in the vote.  <a href="class_g_classes_1_1_g_bag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bucket.html">GBucket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When Train is called, this performs cross-validation on the training set to determine which learner is the best. It then trains that learner with the entire training set.  <a href="class_g_classes_1_1_g_bucket.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_evolutionary_optimizer.html">GEvolutionaryOptimizer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses an evolutionary process to optimize a vector.  <a href="class_g_classes_1_1_g_evolutionary_optimizer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_classes_1_1_path_data.html">PathData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper struct to hold the results from GFile::ParsePath.  <a href="struct_g_classes_1_1_path_data.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_file.html">GFile</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains some useful routines for manipulating files.  <a href="class_g_classes_1_1_g_file.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_compressor.html">GCompressor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_classes_1_1_complex_number.html">ComplexNumber</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_fourier.html">GFourier</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fourier transform.  <a href="class_g_classes_1_1_g_fourier.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>strCmp</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_function.html">GFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class represents a math function. (It might be used, for example, in a plotting tool.).  <a href="class_g_classes_1_1_g_function.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_function_parser.html">GFunctionParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class parses math equations. (This is useful, for example, for plotting tools.).  <a href="class_g_classes_1_1_g_function_parser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_graph_cut.html">GGraphCut</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This implements an optimized max-flow/min-cut algorithm described in "An experimental comparison of min-cut/max-flow algorithms for energy minimization in vision" by Boykov, Y. and Kolmogorov, V. This implementation assumes that edges are undirected.  <a href="class_g_classes_1_1_g_graph_cut.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_graph_edge_iterator.html">GGraphEdgeIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates over the edges that connect to the specified node.  <a href="class_g_classes_1_1_g_graph_edge_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_floyd_warshall.html">GFloydWarshall</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the shortest-cost path between all pairs of vertices in a graph. Takes O(n^3) time.  <a href="class_g_classes_1_1_g_floyd_warshall.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dijkstra.html">GDijkstra</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the shortest path from an origin vertex to all other vertices. Implemented with a binary-heap priority-queue. If the graph is sparse on edges, it will run in about O(n log(n)) time. If the graph is dense, it runs in about O(n^2 log(n)).  <a href="class_g_classes_1_1_g_dijkstra.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_brandes_betweenness_centrality.html">GBrandesBetweennessCentrality</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the number of times that the shortest-path between every pair of points passes over each edge and vertex.  <a href="class_g_classes_1_1_g_brandes_betweenness_centrality.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_atomic_cycle_finder.html">GAtomicCycleFinder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This finds all of the atomic cycles (cycles that cannot be divided into two smaller cycles) in a graph.  <a href="class_g_classes_1_1_g_atomic_cycle_finder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_hash_table_base.html">GHashTableBase</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The base class of hash tables.  <a href="class_g_classes_1_1_g_hash_table_base.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_hash_table_enumerator.html">GHashTableEnumerator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class iterates over the values in a hash table.  <a href="class_g_classes_1_1_g_hash_table_enumerator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_hash_table.html">GHashTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements a typical hash table. (It doesn't take ownership of the objects you add, so you must still delete them yourself.).  <a href="class_g_classes_1_1_g_hash_table.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_const_string_hash_table.html">GConstStringHashTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hash table based on keys of constant strings (or at least strings that won't change during the lifetime of the hash table). It's a good idea to use a <a class="el" href="class_g_classes_1_1_g_heap.html" title="Provides a heap in which to put strings or whatever you need to store. If you need...">GHeap</a> in connection with this class.  <a href="class_g_classes_1_1_g_const_string_hash_table.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_const_string_to_ints_hash_table.html">GConstStringToIntsHashTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hash table based on keys of constant strings (or at least strings that won't change during the lifetime of the hash table). It's a good idea to use a <a class="el" href="class_g_classes_1_1_g_heap.html" title="Provides a heap in which to put strings or whatever you need to store. If you need...">GHeap</a> in connection with this class.  <a href="class_g_classes_1_1_g_const_string_to_ints_hash_table.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_classes_1_1_hash_bucket.html">HashBucket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an internal structure used by <a class="el" href="class_g_classes_1_1_g_hash_table.html" title="Implements a typical hash table. (It doesn&#39;t take ownership of the objects you...">GHashTable</a>.  <a href="struct_g_classes_1_1_hash_bucket.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_hash_table_node.html">HashTableNode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Objects used with <a class="el" href="class_g_classes_1_1_g_node_hash_table.html" title="This is a hash table that uses any object which inherits from HashTableNode as the...">GNodeHashTable</a> should inherit from this class. They must implement two methods (to hash and compare the nodes).  <a href="class_g_classes_1_1_hash_table_node.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_node_hash_table.html">GNodeHashTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a hash table that uses any object which inherits from <a class="el" href="class_g_classes_1_1_hash_table_node.html" title="Objects used with GNodeHashTable should inherit from this class. They must implement...">HashTableNode</a> as the key.  <a href="class_g_classes_1_1_g_node_hash_table.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a heap in which to put strings or whatever you need to store. If you need to allocate space for a lot of small objects, it's much more efficient to use this class than the C++ heap. Plus, you can delete them all by simply deleting the heap. You can't, however, reuse the space for individual objects in this heap.  <a href="class_g_classes_1_1_g_heap.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_hidden_markov_model.html">GHiddenMarkovModel</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_momentum_greedy_search.html">GMomentumGreedySearch</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">At each iteration this algorithm moves in only one dimension. If the situation doesn't improve it tries the opposite direction. If both directions are worse, it decreases the step size for that dimension, otherwise it increases the step size for that dimension.  <a href="class_g_classes_1_1_g_momentum_greedy_search.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_hill_climber.html">GHillClimber</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_annealing.html">GAnnealing</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This algorithm tries the current direction and a slightly perturbed direction at each step. If the perturbed direction resulted in faster improvement, it becomes the new current direction. As long as the current direction yields improvement, it accelerates, otherwise it decelerates.  <a href="class_g_classes_1_1_g_annealing.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_empirical_gradient_descent.html">GEmpiricalGradientDescent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This algorithm does a gradient descent by feeling a small distance out in each dimension to measure the gradient. For efficiency reasons, it only measures the gradient in one dimension (which it cycles round-robin style) per iteration and uses the remembered gradient in the other dimensions.  <a href="class_g_classes_1_1_g_empirical_gradient_descent.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sample_climber.html">GSampleClimber</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a variant of empirical gradient descent that tries to estimate the gradient using a minimal number of samples. It is more efficient than empirical gradient descent, but it only works well if the optimization surface is quite locally linear.  <a href="class_g_classes_1_1_g_sample_climber.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_histogram.html">GHistogram</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gathers values and puts them in bins.  <a href="class_g_classes_1_1_g_histogram.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_temp_buf_helper.html">GTempBufHelper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper class used by the GTEMPBUF macro.  <a href="class_g_classes_1_1_g_temp_buf_helper.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_holder.html">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is very similar to the standard C++ class auto_ptr, except it throws an exception if you try to make a copy of it. This way, it will fail early if you use it in a manner that could result in non-deterministic behavior. (For example, if you create a vector of auto_ptrs, wierd things happen if an oom exception is thrown while resizing the buffer--part of the data will be lost when it reverts back to the original buffer. But if you make a vector of these, it will fail quickly, thus alerting you to the issue.).  <a href="class_g_classes_1_1_holder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_array_holder.html">ArrayHolder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Just like <a class="el" href="class_g_classes_1_1_holder.html" title="This class is very similar to the standard C++ class auto_ptr, except it throws an...">Holder</a>, except for arrays.  <a href="class_g_classes_1_1_array_holder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_file_holder.html">FileHolder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes a file when this object goes out of scope.  <a href="class_g_classes_1_1_file_holder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_vector_of_pointers_holder.html">VectorOfPointersHolder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes all of the pointers in a vector when this object goes out of scope.  <a href="class_g_classes_1_1_vector_of_pointers_holder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1smart__ptr__ref__counter.html">smart_ptr_ref_counter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper class used by the <a class="el" href="class_g_classes_1_1smart__ptr.html" title="A reference-counting smart-pointer.">smart_ptr</a> class.  <a href="class_g_classes_1_1smart__ptr__ref__counter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1smart__ptr.html">smart_ptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A reference-counting smart-pointer.  <a href="class_g_classes_1_1smart__ptr.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_html.html">GHtml</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is for parsing HTML files. It's designed to be very simple. This class might be useful, for example, for building a web-crawler or for extracting readable text from a web page.  <a href="class_g_classes_1_1_g_html.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_image.html">GImage</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an image.  <a href="class_g_classes_1_1_g_image.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_extended_kalman_filter.html">GExtendedKalmanFilter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an implementation of the Extended Kalman Filter. This class is used by alternately calling advance and correct.  <a href="class_g_classes_1_1_g_extended_kalman_filter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel.html">GKernel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The base class for kernel functions. Classes which implement this must provide an "apply" method that applies the kernel to two vectors. Kernels may be combined together to form a more complex kernel, to which the kernel trick will still apply.  <a href="class_g_classes_1_1_g_kernel.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_identity.html">GKernelIdentity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The identity kernel.  <a href="class_g_classes_1_1_g_kernel_identity.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_polynomial.html">GKernelPolynomial</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A polynomial kernel.  <a href="class_g_classes_1_1_g_kernel_polynomial.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_gaussian_r_b_f.html">GKernelGaussianRBF</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Gaussian RBF kernel.  <a href="class_g_classes_1_1_g_kernel_gaussian_r_b_f.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_translate.html">GKernelTranslate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A translation kernel.  <a href="class_g_classes_1_1_g_kernel_translate.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_scale.html">GKernelScale</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A scalar kernel.  <a href="class_g_classes_1_1_g_kernel_scale.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_add.html">GKernelAdd</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An addition kernel.  <a href="class_g_classes_1_1_g_kernel_add.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_multiply.html">GKernelMultiply</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A multiplication kernel.  <a href="class_g_classes_1_1_g_kernel_multiply.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_pow.html">GKernelPow</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A power kernel.  <a href="class_g_classes_1_1_g_kernel_pow.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_exp.html">GKernelExp</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Exponential kernel.  <a href="class_g_classes_1_1_g_kernel_exp.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_normalize.html">GKernelNormalize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Normalizing kernel.  <a href="class_g_classes_1_1_g_kernel_normalize.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_machine.html">GKernelMachine</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An experimental kernel machine. Currently this algorithm is not competitive with state-of-the-art kernel machines.  <a href="class_g_classes_1_1_g_kernel_machine.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_k_n_n.html">GKNN</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The k-Nearest Neighbor learning algorithm.  <a href="class_g_classes_1_1_g_k_n_n.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neighbor_transducer.html">GNeighborTransducer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An instance-based transduction algorithm.  <a href="class_g_classes_1_1_g_neighbor_transducer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_instance_table.html">GInstanceTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This represents a grid of values. It might be useful as a Q-table with Q-learning.  <a href="class_g_classes_1_1_g_instance_table.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_prediction.html">GPrediction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used to represent the predicted distribution made by a supervised learning algorithm. (It is just a shallow wrapper around <a class="el" href="class_g_classes_1_1_g_distribution.html">GDistribution</a>.) It is used in conjunction with calls to <a class="el" href="class_g_classes_1_1_g_supervised_learner.html#45504ebdf2af63db0a7472b705db4a81" title="Evaluate pIn and compute a prediction for pOut. pOut is expected to point to an array...">GSupervisedLearner::predictDistribution</a>. The predicted distributions will be either categorical distributions (for nominal values) or Normal distributions (for continuous values).  <a href="class_g_classes_1_1_g_prediction.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html">GTransducer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class of supervised learning algorithms (that may or may not have an internal model allowing them to generalize rows that were not available at training time). Note that the literature typically refers to supervised learning algorithms that can't generalize (because they lack an internal hypothesis model) as "Semi-supervised". (You cannot generalize with a semi-supervised algorithm--you have to train again with the new rows.).  <a href="class_g_classes_1_1_g_transducer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_supervised_learner.html">GSupervisedLearner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class of algorithms that learn with supervision and have an internal hypothesis model that allows them to generalize rows that were not available at training time.  <a href="class_g_classes_1_1_g_supervised_learner.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_incremental_learner.html">GIncrementalLearner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class of supervised learning algorithms that can learn one row at a time.  <a href="class_g_classes_1_1_g_incremental_learner.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_learner_loader.html">GLearnerLoader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is for loading various learning algorithms from a Twt node. When any learning algorithm is saved, it calls MakeBaseTwtNode, which creates (among other things) a field named "class" which specifies the class name of the algorithm. This class contains methods that will recognize any of the classes in this library and load them. If it doesn't recognize a class, it will either return NULL or throw and exception, depending on the flags you pass to the constructor. Obviously this loader won't recognize any classes that you make. Therefore, you should overload the corresponding method in this class with a new method that will first recognize and load your classes, and then call these methods to handle other types.  <a href="class_g_classes_1_1_g_learner_loader.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_baseline_learner.html">GBaselineLearner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always outputs the label mean (for continuous labels) and the most common class (for nominal labels).  <a href="class_g_classes_1_1_g_baseline_learner.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_identity_function.html">GIdentityFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an implementation of the identity function. It might be useful, for example, as the observation function in a <a class="el" href="class_g_classes_1_1_g_recurrent_model.html" title="This class can be used to implement recurrent neural networks, or recurrent forms...">GRecurrentModel</a> if you want to create a Jordan network.  <a href="class_g_classes_1_1_g_identity_function.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_linear_regressor.html">GLinearRegressor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A linear regression algorithm. Only supports 1 label dim.  <a href="class_g_classes_1_1_g_linear_regressor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_linear_programming.html">GLinearProgramming</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold.html">GManifold</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class stores static methods that are useful for manifold learning.  <a href="class_g_classes_1_1_g_manifold.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold_learner.html">GManifoldLearner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class of manifold learning (aka non-linear dimensionality reducing) algorithms.  <a href="class_g_classes_1_1_g_manifold_learner.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold_sculpting.html">GManifoldSculpting</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manifold Sculpting. A non-linear dimensionality reduction algorithm. (See Gashler, Michael S. and Ventura, Dan and Martinez, Tony. Iterative non-linear dimensionality reduction with manifold sculpting. In Advances in Neural Information Processing Systems 20, pages 513–520, MIT Press, Cambridge, MA, 2008.).  <a href="class_g_classes_1_1_g_manifold_sculpting.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_isomap.html">GIsomap</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Isomap. (A well-known manifold learning algorithm.).  <a href="class_g_classes_1_1_g_isomap.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_l_l_e.html">GLLE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locally Linear Embedding. (A well-known manifold learning algorithm.).  <a href="class_g_classes_1_1_g_l_l_e.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_breadth_first_unfolding.html">GBreadthFirstUnfolding</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A manifold learning algorithm that reduces dimensionality in local neighborhoods, and then stitches the reduced local neighborhoods together using the Kabsch algorithm.  <a href="class_g_classes_1_1_g_breadth_first_unfolding.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_unsupervised_back_prop.html">GUnsupervisedBackProp</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A manifold learning algorithm that uses back-propagation to train a neural net model to map from low-dimensional space to high-dimensional space.  <a href="class_g_classes_1_1_g_unsupervised_back_prop.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html">GMath</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides some useful math functions.  <a href="class_g_classes_1_1_g_math.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_mixture_of_gaussians.html">GMixtureOfGaussians</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class uses Expectency Maximization to find the mixture of Gaussians that best approximates the data in a specified real attribute of a data set.  <a href="class_g_classes_1_1_g_mixture_of_gaussians.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_naive_bayes.html">GNaiveBayes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A naive Bayes classifier.  <a href="class_g_classes_1_1_g_naive_bayes.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_naive_m_l_e.html">GNaiveMLE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This modeler is very similar to Naive Bayes, except even simpler. It just counts the frequency of each output give each input. To generalize, it assumes conditional independence and computes the maximum likelihood output based on the training rows with similar input values.  <a href="class_g_classes_1_1_g_naive_m_l_e.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_naive_instance.html">GNaiveInstance</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an instance-based learner. Instead of finding the k-nearest neighbors of a feature vector, it finds the k-nearst neighbors in each dimension. That is, it finds n*k neighbors, considering each dimension independently. It then combines the label from all of these neighbors to make a prediction. Finding neighbors in this way makes it more robust to high-dimensional datasets. It tends to perform worse than k-nn in low-dimensional space, and better than k-nn in high-dimensional space. (It may be thought of as a cross between a k-nn instance learner and a Naive Bayes learner. It only supports continuous features and labels (so it is common to wrap it in a Categorize filter which will convert nominal features to a categorical distribution of continuous values).  <a href="class_g_classes_1_1_g_naive_instance.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dissimilarity_metric.html">GDissimilarityMetric</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class enables you to define dissimilarity (distance) metrics between two vectors. pScaleFactors is an optional parameter (it can be NULL) that lets the calling class scale the significance of each dimension. Distance metrics that do not mix with this concept may simply ignore any scale factors. Typically, classes that use this should be able to assume that the triangle inequality will hold, but do not necessarily enforce the parallelogram law.  <a href="class_g_classes_1_1_g_dissimilarity_metric.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_row_distance.html">GRowDistance</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This uses Euclidean distance for continuous attributes, and Hamming distance for nominal attributes.  <a href="class_g_classes_1_1_g_row_distance.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_row_distance_scaled.html">GRowDistanceScaled</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This uses Euclidean distance for continuous attributes, and Hamming distance for nominal attributes.  <a href="class_g_classes_1_1_g_row_distance_scaled.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_minkowski_distance.html">GMinkowskiDistance</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolates between manhattan distance (norm=1), Euclidean distance (norm=2), and Chebyshev distance (norm=infinity). Throws an exception if any of the attributes are nominal.  <a href="class_g_classes_1_1_g_minkowski_distance.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neighbor_finder.html">GNeighborFinder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the k-nearest neighbors of each vector in a dataset.  <a href="class_g_classes_1_1_g_neighbor_finder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neighbor_finder_cache_wrapper.html">GNeighborFinderCacheWrapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This wraps a neighbor finding algorithm. It caches the queries for neighbors for the purpose of improving runtime performance.  <a href="class_g_classes_1_1_g_neighbor_finder_cache_wrapper.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neighbor_finder_generalizing.html">GNeighborFinderGeneralizing</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the k-nearest neighbors (in a dataset) of an arbitrary vector (which may or may not be in the dataset).  <a href="class_g_classes_1_1_g_neighbor_finder_generalizing.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_brute_force_neighbor_finder.html">GBruteForceNeighborFinder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds neighbors by measuring the distance to all points. This one should work properly even if the distance metric does not support the triangle inequality.  <a href="class_g_classes_1_1_g_brute_force_neighbor_finder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kd_tree.html">GKdTree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An efficient algorithm for finding neighbors.  <a href="class_g_classes_1_1_g_kd_tree.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_shortcut_pruner.html">GShortcutPruner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This finds the shortcuts in a table of neighbors and replaces them with INVALID_INDEX.  <a href="class_g_classes_1_1_g_shortcut_pruner.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_cycle_cut.html">GCycleCut</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This finds the shortcuts in a table of neighbors and replaces them with INVALID_INDEX.  <a href="class_g_classes_1_1_g_cycle_cut.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold_neighbor_finder.html">GManifoldNeighborFinder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class intelligently selects neighbors for each point in a dataset, such that the neighbors define a good neighborhood for manifold learning. A relaxation technique is used to ensure that neighbors lie on a consistent tangent-space while remaining close to the point. This makes manifold learning possible with difficult (somtimes even self-intersecting) manifolds.  <a href="class_g_classes_1_1_g_manifold_neighbor_finder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dynamic_system_neighbor_finder.html">GDynamicSystemNeighborFinder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A neighbor finder that specializes in dynamical systems. It determines neighbors by searching for the shortest path of actions between observations, and computes the distance as the length of the path.  <a href="class_g_classes_1_1_g_dynamic_system_neighbor_finder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sequence_neighbor_finder.html">GSequenceNeighborFinder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple neighbor-finder that reports the nearest neighbors in the sequence. (That is, the previous and next rows are the closest neighbors.) The distance is sequential distance to the neighbor (not squared).  <a href="class_g_classes_1_1_g_sequence_neighbor_finder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neuron.html">GNeuron</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a single neuron in a neural network.  <a href="class_g_classes_1_1_g_neuron.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neural_net_layer.html">GNeuralNetLayer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a layer of neurons in a neural network.  <a href="class_g_classes_1_1_g_neural_net_layer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_back_prop_weight.html">GBackPropWeight</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An internal class used by <a class="el" href="class_g_classes_1_1_g_back_prop.html" title="This class performs backpropagation on a neural network. (It is a separate class...">GBackProp</a>.  <a href="class_g_classes_1_1_g_back_prop_weight.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_back_prop_neuron.html">GBackPropNeuron</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An internal class used by <a class="el" href="class_g_classes_1_1_g_back_prop.html" title="This class performs backpropagation on a neural network. (It is a separate class...">GBackProp</a>.  <a href="class_g_classes_1_1_g_back_prop_neuron.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_back_prop_layer.html">GBackPropLayer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An internal class used by <a class="el" href="class_g_classes_1_1_g_back_prop.html" title="This class performs backpropagation on a neural network. (It is a separate class...">GBackProp</a>.  <a href="class_g_classes_1_1_g_back_prop_layer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_back_prop.html">GBackProp</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class performs backpropagation on a neural network. (It is a separate class, because it is only needed while training. There is no reason to waste this space after training is complete, or if you choose to use a different technique to train the neural network.).  <a href="class_g_classes_1_1_g_back_prop.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neural_net.html">GNeuralNet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An artificial neural network.  <a href="class_g_classes_1_1_g_neural_net.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neural_net_inverse_layer.html">GNeuralNetInverseLayer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper class used by <a class="el" href="class_g_classes_1_1_g_neural_net_pseudo_inverse.html" title="Computes the pseudo-inverse of a neural network.">GNeuralNetPseudoInverse</a>.  <a href="class_g_classes_1_1_g_neural_net_inverse_layer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neural_net_pseudo_inverse.html">GNeuralNetPseudoInverse</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the pseudo-inverse of a neural network.  <a href="class_g_classes_1_1_g_neural_net_pseudo_inverse.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_target_function.html">GTargetFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The optimizer seeks to find values that minimize this target function.  <a href="class_g_classes_1_1_g_target_function.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_optimizer.html">GOptimizer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class of all search algorithms that can jump to any vector in the search space seek the vector that minimizes error.  <a href="class_g_classes_1_1_g_optimizer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_parallel_optimizers.html">GParallelOptimizers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class simplifies simultaneously solving several optimization problems.  <a href="class_g_classes_1_1_g_parallel_optimizers.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_action_path_state.html">GActionPathState</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_action_path.html">GActionPath</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_action_path_search.html">GActionPathSearch</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class of search algorithms that can only perform a discreet set of actions (as opposed to jumping to anywhere in the search space), and seeks to minimize the error of a path of actions.  <a href="class_g_classes_1_1_g_action_path_search.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_particle_swarm.html">GParticleSwarm</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An optimization algorithm inspired by flocking birds.  <a href="class_g_classes_1_1_g_particle_swarm.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_rubber_ball_swarm.html">GRubberBallSwarm</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an algorithm for finding good starting points within a constrained optimization problem. It works by simulating "rubber balls" which bounce around inside the constrained region. After many iterations, they tend to be spread somewhat uniformly, even with very complex constrained shapes. The balls learn to approximate the shape of the shell, so if the room is wider than it is tall, the balls will learn to bounce sideways more often than vertically.  <a href="class_g_classes_1_1_g_rubber_ball_swarm.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_plot_label_spacer.html">GPlotLabelSpacer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you need to place grid lines or labels at regular intervals (like 1000, 2000, 3000, 4000... or 20, 25, 30, 35... or 0, 2, 4, 6, 8, 10...) this class will help you pick where to place the labels so that there are a reasonable number of them, and they all land on nice label values.  <a href="class_g_classes_1_1_g_plot_label_spacer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_plot_label_spacer_logarithmic.html">GPlotLabelSpacerLogarithmic</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_g_classes_1_1_g_plot_label_spacer.html" title="If you need to place grid lines or labels at regular intervals (like 1000, 2000,...">GPlotLabelSpacer</a>, except for logarithmic grids. To plot in logarithmic space, set your plot window to have a range from log_e(min) to log_e(max). When you actually plot things, plot them at log_e(x), where x is the position of the thing you want to plot.  <a href="class_g_classes_1_1_g_plot_label_spacer_logarithmic.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_plot_window.html">GPlotWindow</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class makes it easy to plot points and functions on 2D cartesian coordinates.  <a href="class_g_classes_1_1_g_plot_window.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_agent_action_iterator.html">GAgentActionIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates through all the actions that are valid in the current state. If actions are continuous or very numerous, this should sample valid actions in a random order. The caller may decide that it has sampled enough at any time.  <a href="class_g_classes_1_1_g_agent_action_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_discrete_action_iterator.html">GDiscreteActionIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a simple and common action iterator that can be used when there is a discrete set of possible actions.  <a href="class_g_classes_1_1_g_discrete_action_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_policy_learner.html">GPolicyLearner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class for algorithms that learn a policy.  <a href="class_g_classes_1_1_g_policy_learner.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_peach_agent.html">GPeachAgent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an experimental policy-learning algorithm. It's currently too slow to be practical.  <a href="class_g_classes_1_1_g_peach_agent.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_polynomial.html">GPolynomial</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This regresses a multi-dimensional polynomial to fit the data.  <a href="class_g_classes_1_1_g_polynomial.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_priority_queue_entry.html">GPriorityQueueEntry</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An internal class used by <a class="el" href="class_g_classes_1_1_g_priority_queue.html" title="An implementation of a double-ended priority queue.">GPriorityQueue</a>. You should not use this class directly.  <a href="class_g_classes_1_1_g_priority_queue_entry.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_priority_queue.html">GPriorityQueue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of a double-ended priority queue.  <a href="class_g_classes_1_1_g_priority_queue.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a 64-bit pseudo-random number generator.  <a href="class_g_classes_1_1_g_rand.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_rect.html">GRect</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a rectangular region with integers.  <a href="class_g_classes_1_1_g_rect.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_float_rect.html">GFloatRect</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a rectangular region with floats.  <a href="class_g_classes_1_1_g_float_rect.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_double_rect.html">GDoubleRect</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a rectangular region with doubles.  <a href="class_g_classes_1_1_g_double_rect.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_region_ajacency_graph.html">GRegionAjacencyGraph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The base class for region ajacency graphs. These are useful for breaking down an image into patches of similar color.  <a href="class_g_classes_1_1_g_region_ajacency_graph.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g2_d_region_graph.html">G2DRegionGraph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements a region adjacency graph for 2D images, and lets you merge similar regions to create a hierarchical breakdown of the image.  <a href="class_g_classes_1_1_g2_d_region_graph.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_region_border_iterator.html">GRegionBorderIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates the border of a 2D region by running around the border and reporting the coordinates of each interior border pixel and the direction to the edge. It goes in a counter-clockwise direction.  <a href="class_g_classes_1_1_g_region_border_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_region_area_iterator.html">GRegionAreaIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates over all the pixels in an image that have the same color and are transitively adjacent. In other words, if you were to flood-fill a the specified point, this returns all the pixels that would be changed.  <a href="class_g_classes_1_1_g_region_area_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sub_image_finder.html">GSubImageFinder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class uses Fourier phase correlation to efficiently find sub-images within a larger image.  <a href="class_g_classes_1_1_g_sub_image_finder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sub_image_finder2.html">GSubImageFinder2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class uses heuristics to find sub-images within a larger image. It is slower, but more stable than <a class="el" href="class_g_classes_1_1_g_sub_image_finder.html" title="This class uses Fourier phase correlation to efficiently find sub-images within a...">GSubImageFinder</a>.  <a href="class_g_classes_1_1_g_sub_image_finder2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_q_learner.html">GQLearner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The base class of a Q-Learner. To use this class, there are four abstract methods you'll need to implement. See also the comment for <a class="el" href="class_g_classes_1_1_g_policy_learner.html" title="This is the base class for algorithms that learn a policy.">GPolicyLearner</a>.  <a href="class_g_classes_1_1_g_q_learner.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_incremental_learner_q_agent.html">GIncrementalLearnerQAgent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an implementation of <a class="el" href="class_g_classes_1_1_g_q_learner.html" title="The base class of a Q-Learner. To use this class, there are four abstract methods...">GQLearner</a> that uses an incremental learner for its Q-table and a SoftMax (usually pick the best action, but sometimes randomly pick the action) strategy to balance between exploration vs exploitation. To use this class, you need to supply an incremental learner (see the comment for the constructor for more details) and to implement the GetRewardForLastAction method.  <a href="class_g_classes_1_1_g_incremental_learner_q_agent.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html">GSelfOrganizingMap</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of a Kohonen map.  <a href="class_g_classes_1_1_g_self_organizing_map.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sparse_matrix_element.html">GSparseMatrixElement</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a helper class used internally by <a class="el" href="class_g_classes_1_1_g_sparse_matrix.html" title="This class simultaneously stores a row-compressed sparse matrix and a column-compressed...">GSparseMatrix</a>.  <a href="class_g_classes_1_1_g_sparse_matrix_element.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sparse_matrix.html">GSparseMatrix</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class simultaneously stores a row-compressed sparse matrix and a column-compressed sparse matrix. It updates both of them.  <a href="class_g_classes_1_1_g_sparse_matrix.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_spin_lock.html">GSpinLock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A spin-lock for synchronization purposes.  <a href="class_g_classes_1_1_g_spin_lock.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_spin_lock_holder.html">GSpinLockHolder</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_brute_force_search.html">GBruteForceSearch</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This performs a brute force search with uniform sampling over the unit hypercube with increasing granularity. (Your target function should scale the candidate vectors as necessary to cover the desired space.).  <a href="class_g_classes_1_1_g_brute_force_search.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_random_search.html">GRandomSearch</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">At each iteration, this tries a random vector from the unit hypercube. (Your target function should scale the candidate vectors as necessary to cover the desired space.).  <a href="class_g_classes_1_1_g_random_search.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_probe_search.html">GProbeSearch</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is somewhat of a multi-dimensional version of binary-search. It greedily probes the best choices first, but then starts trying the opposite choices at the higher divisions so that it can also handle non-monotonic target functions. Each iteration performs a binary (divide-and-conquer) search within the unit hypercube. (Your target function should scale the candidate vectors as necessary to cover the desired space.) Because the high-level divisions are typically less correlated with the quality of the final result than the low-level divisions, it searches through the space of possible "probes" by toggling choices in the order from high level to low level. In low-dimensional space, this algorithm tends to quickly find good solutions, especially if the target function is somewhat smooth. In high-dimensional space, the number of iterations to find a good solution seems to grow exponentially.  <a href="class_g_classes_1_1_g_probe_search.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_stemmer.html">GStemmer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class just wraps the Porter Stemmer. It finds the stems of words. Examples: "cats"-&gt;"cat" "dogs"-&gt;"dog" "fries"-&gt;"fri" "fishes"-&gt;"fish" "pies"-&gt;"pi" "lovingly"-&gt;"lovingli" "candy"-&gt;"candi" "babies"-&gt;"babi" "bus"-&gt;"bu" "busses"-&gt;"buss" "women"-&gt;"women" "hasty"-&gt;"hasti" "hastily"-&gt;"hastili" "fly"-&gt;"fly" "kisses"-&gt;"kiss" "goes"-&gt;"goe" "brought"-&gt;"brought" As you can see the stems aren't always real words, but that's okay as long as it produces the same stem for words that have the same etymological roots. Even then it still isn't perfect (notice it got "bus" wrong), but it should still improve analysis somewhat in many cases.  <a href="class_g_classes_1_1_g_stemmer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_string_chopper.html">GStringChopper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class chops a big string at word breaks so you can display it intelligently on multiple lines.  <a href="class_g_classes_1_1_g_string_chopper.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_system_learner.html">GSystemLearner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class for algorithms that learn to model dynamical systems.  <a href="class_g_classes_1_1_g_system_learner.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_recurrent_model.html">GRecurrentModel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class can be used to implement recurrent neural networks, or recurrent forms of other supervised models.  <a href="class_g_classes_1_1_g_recurrent_model.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_word_iterator.html">GWordIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This iterates over the words in a block of text.  <a href="class_g_classes_1_1_g_word_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_word_stats.html">GWordStats</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores statistics about each word in a <a class="el" href="class_g_classes_1_1_g_vocabulary.html" title="This is a helper class which is useful for text-mining. It collects words, stems...">GVocabulary</a>.  <a href="class_g_classes_1_1_g_word_stats.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vocabulary.html">GVocabulary</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a helper class which is useful for text-mining. It collects words, stems them, filters them through a list of stop-words, and assigns a discrete number to each word.  <a href="class_g_classes_1_1_g_vocabulary.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_thread.html">GThread</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper for PThreads on Linux and for some corresponding WIN32 api on Windows.  <a href="class_g_classes_1_1_g_thread.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_time.html">GTime</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides some time-related functions.  <a href="class_g_classes_1_1_g_time.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transform.html">GTransform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class of algorithms that transform data without supervision.  <a href="class_g_classes_1_1_g_transform.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transform_chainer.html">GTransformChainer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This wraps two unsupervised learners to make a single unsupervised learner that performs both transforms sequentially.  <a href="class_g_classes_1_1_g_transform_chainer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_incremental_transform.html">GIncrementalTransform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class of algorithms that can transform data one row at a time without supervision.  <a href="class_g_classes_1_1_g_incremental_transform.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_two_way_incremental_transform.html">GTwoWayIncrementalTransform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the base class of algorithms that can transform data one row at a time without supervision, and can (un)transform a row back to its original form if necessary.  <a href="class_g_classes_1_1_g_two_way_incremental_transform.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_filter.html">GFilter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class enables functionality similar to filters in Weka. It wraps a modeler and transforms data before it is passed to the modeler, and/or after the modeler passes data back. For example, suppose that you wish to use <a class="el" href="class_g_classes_1_1_g_naive_bayes.html" title="A naive Bayes classifier.">GNaiveBayes</a> (which only supports discrete attributes) with a dataset that contains continuous attributes. You could use this class to wrap <a class="el" href="class_g_classes_1_1_g_discretize.html" title="This transform uses buckets to convert continuous data into discrete data. It is...">GDiscretize</a> around <a class="el" href="class_g_classes_1_1_g_naive_bayes.html" title="A naive Bayes classifier.">GNaiveBayes</a> to create a naive bayes that can operate on both continuous and discrete data. As another example, if you have a modeler that only supports real attributes, you could wrap it with <a class="el" href="class_g_classes_1_1_g_nominal_to_cat.html" title="This is sort-of the opposite of discretize. It converts each nominal attribute to...">GNominalToCat</a> to create a modeler that can operate on nominal data too. Or, if your modeler expects values within a certain range, you could use <a class="el" href="class_g_classes_1_1_g_normalize.html" title="This transform scales and shifts continuous values to make them fall within a specified...">GNormalize</a> to ensure that the modeler receives values within that range while leaving the caller free to pass in values with whatever range it prefers.  <a href="class_g_classes_1_1_g_filter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_p_c_a.html">GPCA</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Principal Component Analysis. (Computes the principal components about the mean of the data when you call train. The transformed (reduced-dimensional) data will have a mean about the origin.).  <a href="class_g_classes_1_1_g_p_c_a.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_p_c_a_rotate_only.html">GPCARotateOnly</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Principle Component Analysis without the projection. It only rotates axes to align with the first few principal components.  <a href="class_g_classes_1_1_g_p_c_a_rotate_only.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_noise_generator.html">GNoiseGenerator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Just generates Gaussian noise.  <a href="class_g_classes_1_1_g_noise_generator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_pair_product.html">GPairProduct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates data by computing the product of each pair of attributes. This is useful for augmenting data.  <a href="class_g_classes_1_1_g_pair_product.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_attribute_selector.html">GAttributeSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates subsets of data that contain only the most relevant features for predicting the labels. The train method of this class produces a ranked ordering of the feature attributes by training a single-layer neural network, and deselecting the weakest attribute until all attributes have been deselected. The transform method uses only the highest-ranked attributes.  <a href="class_g_classes_1_1_g_attribute_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_nominal_to_cat.html">GNominalToCat</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is sort-of the opposite of discretize. It converts each nominal attribute to a categorical distribution by representing each value using the corresponding row of the identity matrix. For example, if a certain nominal attribute has 4 possible values, then a value of 3 would be encoded as the vector 0 0 1 0. When predictions are converted back to nominal values, the mode of the categorical distribution is used as the predicted value. (This is similar to Weka's NominalToBinaryFilter.).  <a href="class_g_classes_1_1_g_nominal_to_cat.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_normalize.html">GNormalize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This transform scales and shifts continuous values to make them fall within a specified range.  <a href="class_g_classes_1_1_g_normalize.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_discretize.html">GDiscretize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This transform uses buckets to convert continuous data into discrete data. It is common to use <a class="el" href="class_g_classes_1_1_g_filter.html" title="This class enables functionality similar to filters in Weka. It wraps a modeler and...">GFilter</a> to combine this with your favorite modeler (which only supports discrete values) to create a modeler that can also support continuous values as well.  <a href="class_g_classes_1_1_g_discretize.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_classes_1_1_g_twt_list.html">GTwtList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_twt_node.html">GTwtNode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a single node in the DOM of a <a class="el" href="class_g_classes_1_1_g_twt_doc.html" title="Twt is a text-based data format, somewhat like XML. The major differences are: XML...">GTwtDoc</a>.  <a href="class_g_classes_1_1_g_twt_node.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_twt_doc.html">GTwtDoc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Twt is a text-based data format, somewhat like XML. The major differences are: XML is bloated, slow, designed for human readability, feature-rich, and hard to fully implement. Twt is compact, fast, designed for simplicity of machine parsing, simple, and easy to fully implement. (Plus, <a class="el" href="class_g_classes_1_1_g_twt_node.html" title="Represents a single node in the DOM of a GTwtDoc.">GTwtNode</a> has methods that will convert to/from XML, so you're never stuck if you use Twt as your file format.).  <a href="class_g_classes_1_1_g_twt_doc.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html">GVec</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains some useful functions for operating on vectors.  <a href="class_g_classes_1_1_g_vec.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_index_vec.html">GIndexVec</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Useful functions for operating on vectors of indexes.  <a href="class_g_classes_1_1_g_index_vec.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_coord_vector_iterator.html">GCoordVectorIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An iterator for an n-dimensional coordinate vector. For example, suppose you have a 4-dimensional 2x3x2x1 grid, and you want to iterate through its coordinates: (0000, 0010, 0100, 0110, 0200, 0210, 1000, 1010, 1100, 1110, 1200, 1210). This class will iterate over coordinate vectors in this manner. (For 0-dimensional coordinate vectors, it behaves as though the origin is the only valid coordinate.).  <a href="class_g_classes_1_1_g_coord_vector_iterator.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#05e6635da5dd8c2ed9fbca0de1888922">DaemonMainFunc</a> )(void *pArg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#6b3b9015fd3581c392397706fb6a00a3">sighandler_t</a> )(int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="class_g_classes_1_1smart__ptr.html">smart_ptr</a>&lt; <a class="el" href="class_g_classes_1_1_g_relation.html">GRelation</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#167d05d64ce9a5f21994c18f1834e820">sp_relation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#719fc65b9fbfb3caf3712bd926c2fdff">EnsembleProgressCallback</a> )(void *pThis, int i, int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#4e2f99ff8c7fd6755d3d32a025500b3b">RepValidateCallback</a> )(void *pThis, int nRep, int nFold, int labelDims, double *pFoldResults)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef double(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#e2576f1cef5c00b03a80fb750ce2f8ae">MathFunc</a> )(void *pThis, double x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#70c393a5da93ac55bc41134644697609">PointerComparer</a> )(void *pThis, void *pA, void *pB)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned long long int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#17e0716ae01035a6bf7aae9f9bbb8941">uint64</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#6464bd53c40d63b4323011b89292c25e">ThrowError</a> (const char *s1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#e266a273da420b27b28b20e638463d51">rgbToHsv</a> (unsigned int c, float *pHue, float *pSaturation, float *pValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#b0156b4be8eaedb8c65356ce9b50a358">gAHSV</a> (int alpha, float hue, float saturation, float value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#b2bb631e561f25fe89748d2c00aa8d4c">ClipChan</a> (int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#627d51e02a0b5fc771faca02494f21b5">gRGB</a> (int r, int g, int b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#4c96c5a192841890ff163cd8176aa0ac">gARGB</a> (int a, int r, int g, int b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#7f13f70b83aa2dc2351695985411c0e9">gFromGray</a> (int gray)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#ec68f053b2da8fe49d9bd0b3c9dbfd27">abgrToArgb</a> (unsigned int rgba)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#c62d5d7ffc509856d28e534e00803cb9">MixColors</a> (unsigned int a, unsigned int b, int nRatio)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#f285ab4787ae320756ab77780062cab5">MultiplyBrightness</a> (unsigned int c, float f)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#e70c96238e9b027a50b2b7befb7a915d">rgbToHex</a> (char *pOutHex, unsigned int c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#18c717a01145b96150c053c61f793979">hexToRgb</a> (const char *szHex)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#4479a47a2cd6c533d2dc1b53fb6f893e">MIN</a> (const T &amp;a, const T &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#b33d834314f21ebc3bf3cf9fe67c5d50">MAX</a> (const T &amp;a, const T &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#3445356db68a7f4060d4a60bd9ae1e61">ABS</a> (const T a)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#85499c08be1fc47b8cc1bd0cac041f0f">GAssertFailed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#c1485ad49ad260dc155938c644d22c00">gformat</a> (char c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#afa7f62aad97639f2a7595ba3d277b0c">gformat</a> (int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#20812c81928834ff83e91e586cbdccde">gformat</a> (unsigned int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#881dbb6add4e58f704ed7e421fbaf87a">gformat</a> (double d, int precision=14)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#8770c9e0d2ae66e703d3a58b3b3f1a5b">ThrowError</a> (const char *s1, const char *s2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#e3d991870bd520136f7936669b98db75">ThrowError</a> (const char *s1, const char *s2, const char *s3)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#128b41a343d41fdf6e168b8820e71199">ThrowError</a> (const char *s1, const char *s2, const char *s3, const char *s4)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#73450c6f56ca40b70eb5f4929873fc98">ThrowError</a> (const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#814c67997ea83837ad6d945315c2db5b">ThrowError</a> (const char *s1, const char *s2, const char *s3, const char *s4, const char *s5, const char *s6)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#78b54cdb9f47d9dba881bcde379cdcc5">ThrowError</a> (const char *s1, const char *s2, const char *s3, const char *s4, const char *s5, const char *s6, const char *s7)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#c299b5ca10e5219ab689162505bb2f45">_stricmp</a> (const char *szA, const char *szB)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#f3f892c5e72c1d1c4f8e3c9888c4d68a">_strnicmp</a> (const char *szA, const char *szB, int len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#bf2d5c0e6bc3b0cb734034337f89241e">filelength</a> (int filedes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#38b6833862b4bcf9383ff1689e96a886">safe_strcpy</a> (char *szDest, const char *szSrc, int nDestBufferSize)</td></tr>

</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="05e6635da5dd8c2ed9fbca0de1888922"></a><!-- doxytag: member="GClasses::DaemonMainFunc" ref="05e6635da5dd8c2ed9fbca0de1888922" args=")(void *pArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namespace_g_classes.html#05e6635da5dd8c2ed9fbca0de1888922">GClasses::DaemonMainFunc</a>)(void *pArg)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="719fc65b9fbfb3caf3712bd926c2fdff"></a><!-- doxytag: member="GClasses::EnsembleProgressCallback" ref="719fc65b9fbfb3caf3712bd926c2fdff" args=")(void *pThis, int i, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namespace_g_classes.html#719fc65b9fbfb3caf3712bd926c2fdff">GClasses::EnsembleProgressCallback</a>)(void *pThis, int i, int n)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e2576f1cef5c00b03a80fb750ce2f8ae"></a><!-- doxytag: member="GClasses::MathFunc" ref="e2576f1cef5c00b03a80fb750ce2f8ae" args=")(void *pThis, double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double(* <a class="el" href="namespace_g_classes.html#e2576f1cef5c00b03a80fb750ce2f8ae">GClasses::MathFunc</a>)(void *pThis, double x)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="70c393a5da93ac55bc41134644697609"></a><!-- doxytag: member="GClasses::PointerComparer" ref="70c393a5da93ac55bc41134644697609" args=")(void *pThis, void *pA, void *pB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="namespace_g_classes.html#70c393a5da93ac55bc41134644697609">GClasses::PointerComparer</a>)(void *pThis, void *pA, void *pB)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4e2f99ff8c7fd6755d3d32a025500b3b"></a><!-- doxytag: member="GClasses::RepValidateCallback" ref="4e2f99ff8c7fd6755d3d32a025500b3b" args=")(void *pThis, int nRep, int nFold, int labelDims, double *pFoldResults)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namespace_g_classes.html#4e2f99ff8c7fd6755d3d32a025500b3b">GClasses::RepValidateCallback</a>)(void *pThis, int nRep, int nFold, int labelDims, double *pFoldResults)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6b3b9015fd3581c392397706fb6a00a3"></a><!-- doxytag: member="GClasses::sighandler_t" ref="6b3b9015fd3581c392397706fb6a00a3" args=")(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namespace_g_classes.html#6b3b9015fd3581c392397706fb6a00a3">GClasses::sighandler_t</a>)(int)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="167d05d64ce9a5f21994c18f1834e820"></a><!-- doxytag: member="GClasses::sp_relation" ref="167d05d64ce9a5f21994c18f1834e820" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_g_classes_1_1smart__ptr.html">smart_ptr</a>&lt;<a class="el" href="class_g_classes_1_1_g_relation.html">GRelation</a>&gt; <a class="el" href="class_g_classes_1_1smart__ptr.html">GClasses::sp_relation</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="17e0716ae01035a6bf7aae9f9bbb8941"></a><!-- doxytag: member="GClasses::uint64" ref="17e0716ae01035a6bf7aae9f9bbb8941" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long int <a class="el" href="namespace_g_classes.html#17e0716ae01035a6bf7aae9f9bbb8941">GClasses::uint64</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c299b5ca10e5219ab689162505bb2f45"></a><!-- doxytag: member="GClasses::_stricmp" ref="c299b5ca10e5219ab689162505bb2f45" args="(const char *szA, const char *szB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GClasses::_stricmp           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f3f892c5e72c1d1c4f8e3c9888c4d68a"></a><!-- doxytag: member="GClasses::_strnicmp" ref="f3f892c5e72c1d1c4f8e3c9888c4d68a" args="(const char *szA, const char *szB, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GClasses::_strnicmp           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ec68f053b2da8fe49d9bd0b3c9dbfd27"></a><!-- doxytag: member="GClasses::abgrToArgb" ref="ec68f053b2da8fe49d9bd0b3c9dbfd27" args="(unsigned int rgba)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::abgrToArgb           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rgba</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3445356db68a7f4060d4a60bd9ae1e61"></a><!-- doxytag: member="GClasses::ABS" ref="3445356db68a7f4060d4a60bd9ae1e61" args="(const T a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T GClasses::ABS           </td>
          <td>(</td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b2bb631e561f25fe89748d2c00aa8d4c"></a><!-- doxytag: member="GClasses::ClipChan" ref="b2bb631e561f25fe89748d2c00aa8d4c" args="(int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GClasses::ClipChan           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="bf2d5c0e6bc3b0cb734034337f89241e"></a><!-- doxytag: member="GClasses::filelength" ref="bf2d5c0e6bc3b0cb734034337f89241e" args="(int filedes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long GClasses::filelength           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>filedes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b0156b4be8eaedb8c65356ce9b50a358"></a><!-- doxytag: member="GClasses::gAHSV" ref="b0156b4be8eaedb8c65356ce9b50a358" args="(int alpha, float hue, float saturation, float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::gAHSV           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>hue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>saturation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4c96c5a192841890ff163cd8176aa0ac"></a><!-- doxytag: member="GClasses::gARGB" ref="4c96c5a192841890ff163cd8176aa0ac" args="(int a, int r, int g, int b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::gARGB           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="85499c08be1fc47b8cc1bd0cac041f0f"></a><!-- doxytag: member="GClasses::GAssertFailed" ref="85499c08be1fc47b8cc1bd0cac041f0f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GAssertFailed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="881dbb6add4e58f704ed7e421fbaf87a"></a><!-- doxytag: member="GClasses::gformat" ref="881dbb6add4e58f704ed7e421fbaf87a" args="(double d, int precision=14)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GClasses::gformat           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>precision</em> = <code>14</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="20812c81928834ff83e91e586cbdccde"></a><!-- doxytag: member="GClasses::gformat" ref="20812c81928834ff83e91e586cbdccde" args="(unsigned int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GClasses::gformat           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="afa7f62aad97639f2a7595ba3d277b0c"></a><!-- doxytag: member="GClasses::gformat" ref="afa7f62aad97639f2a7595ba3d277b0c" args="(int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GClasses::gformat           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c1485ad49ad260dc155938c644d22c00"></a><!-- doxytag: member="GClasses::gformat" ref="c1485ad49ad260dc155938c644d22c00" args="(char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GClasses::gformat           </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7f13f70b83aa2dc2351695985411c0e9"></a><!-- doxytag: member="GClasses::gFromGray" ref="7f13f70b83aa2dc2351695985411c0e9" args="(int gray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::gFromGray           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gray</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="627d51e02a0b5fc771faca02494f21b5"></a><!-- doxytag: member="GClasses::gRGB" ref="627d51e02a0b5fc771faca02494f21b5" args="(int r, int g, int b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::gRGB           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="18c717a01145b96150c053c61f793979"></a><!-- doxytag: member="GClasses::hexToRgb" ref="18c717a01145b96150c053c61f793979" args="(const char *szHex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::hexToRgb           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szHex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b33d834314f21ebc3bf3cf9fe67c5d50"></a><!-- doxytag: member="GClasses::MAX" ref="b33d834314f21ebc3bf3cf9fe67c5d50" args="(const T &amp;a, const T &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; GClasses::MAX           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4479a47a2cd6c533d2dc1b53fb6f893e"></a><!-- doxytag: member="GClasses::MIN" ref="4479a47a2cd6c533d2dc1b53fb6f893e" args="(const T &amp;a, const T &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; GClasses::MIN           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c62d5d7ffc509856d28e534e00803cb9"></a><!-- doxytag: member="GClasses::MixColors" ref="c62d5d7ffc509856d28e534e00803cb9" args="(unsigned int a, unsigned int b, int nRatio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::MixColors           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nRatio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f285ab4787ae320756ab77780062cab5"></a><!-- doxytag: member="GClasses::MultiplyBrightness" ref="f285ab4787ae320756ab77780062cab5" args="(unsigned int c, float f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::MultiplyBrightness           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e70c96238e9b027a50b2b7befb7a915d"></a><!-- doxytag: member="GClasses::rgbToHex" ref="e70c96238e9b027a50b2b7befb7a915d" args="(char *pOutHex, unsigned int c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GClasses::rgbToHex           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pOutHex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e266a273da420b27b28b20e638463d51"></a><!-- doxytag: member="GClasses::rgbToHsv" ref="e266a273da420b27b28b20e638463d51" args="(unsigned int c, float *pHue, float *pSaturation, float *pValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::rgbToHsv           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>pHue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>pSaturation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>pValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="38b6833862b4bcf9383ff1689e96a886"></a><!-- doxytag: member="GClasses::safe_strcpy" ref="38b6833862b4bcf9383ff1689e96a886" args="(char *szDest, const char *szSrc, int nDestBufferSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GClasses::safe_strcpy           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>szDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>szSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDestBufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="78b54cdb9f47d9dba881bcde379cdcc5"></a><!-- doxytag: member="GClasses::ThrowError" ref="78b54cdb9f47d9dba881bcde379cdcc5" args="(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5, const char *s6, const char *s7)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="814c67997ea83837ad6d945315c2db5b"></a><!-- doxytag: member="GClasses::ThrowError" ref="814c67997ea83837ad6d945315c2db5b" args="(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5, const char *s6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="73450c6f56ca40b70eb5f4929873fc98"></a><!-- doxytag: member="GClasses::ThrowError" ref="73450c6f56ca40b70eb5f4929873fc98" args="(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="128b41a343d41fdf6e168b8820e71199"></a><!-- doxytag: member="GClasses::ThrowError" ref="128b41a343d41fdf6e168b8820e71199" args="(const char *s1, const char *s2, const char *s3, const char *s4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e3d991870bd520136f7936669b98db75"></a><!-- doxytag: member="GClasses::ThrowError" ref="e3d991870bd520136f7936669b98db75" args="(const char *s1, const char *s2, const char *s3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8770c9e0d2ae66e703d3a58b3b3f1a5b"></a><!-- doxytag: member="GClasses::ThrowError" ref="8770c9e0d2ae66e703d3a58b3b3f1a5b" args="(const char *s1, const char *s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6464bd53c40d63b4323011b89292c25e"></a><!-- doxytag: member="GClasses::ThrowError" ref="6464bd53c40d63b4323011b89292c25e" args="(const char *s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Nov 2 14:18:23 2010 for GClasses by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
