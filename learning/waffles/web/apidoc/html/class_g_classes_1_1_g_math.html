<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>GClasses: GClasses::GMath Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_g_classes.html">GClasses</a>::<a class="el" href="class_g_classes_1_1_g_math.html">GMath</a>
  </div>
</div>
<div class="contents">
<h1>GClasses::GMath Class Reference</h1><!-- doxytag: class="GClasses::GMath" -->Provides some useful math functions.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;GMath.h&gt;</code>
<p>

<p>
<a href="class_g_classes_1_1_g_math-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#9bc4d4e675d993c54b2bb0a2d44f6000">signedRoot</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns sign(x) * sqrt(ABS(x)).  <a href="#9bc4d4e675d993c54b2bb0a2d44f6000"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#44924e1ac8233faa08478d06fee9e75c">logistic</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The logistic sigmoid function.  <a href="#44924e1ac8233faa08478d06fee9e75c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#7a53cae14448fbd106574a5d5ff588a2">logisticDerivative</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This evaluates the derivative of the sigmoid function.  <a href="#7a53cae14448fbd106574a5d5ff588a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#04534629d9a3aae25237dc634b539ff2">logisticInverse</a> (double y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the inverse of the logistic sigmoid function.  <a href="#04534629d9a3aae25237dc634b539ff2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#0721e5f9c20e75e3ca0380f79c1d5a57">softStep</a> (double x, double steepness)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates a function that always passes through (0, 0), (1, 1), and (0.5, 0.5). The slope at (0.5, 0.5) will be "steepness". If steepness is &gt; 1, then the slope at (0, 0) and (1, 1) will be 0. If steepness is &lt; 1, the slope at (0, 0) and (1, 1) will be infinity. If steepness is exactly 1, the slope will be 1 at those points. softStep(1/x, 2) = PI*cauchy(x-1).  <a href="#0721e5f9c20e75e3ca0380f79c1d5a57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#91e805fbbee162296b31014d5e6b9954">interpolatingFunc</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A soft step function with a very high degree of continuity at 0 and 1.  <a href="#91e805fbbee162296b31014d5e6b9954"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#8bde82aae4a522d264eb51cebb06af2c">bend</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bend function has a slope of 1 at very negative values of x, and 2 at very positive values of x, and a smooth transition in between.  <a href="#8bde82aae4a522d264eb51cebb06af2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#9589424fa4a4545c027c907d5c7fa9e0">bendInverse</a> (double y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The inverse of the bend function.  <a href="#9589424fa4a4545c027c907d5c7fa9e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#e0abc5f931a45e7da829c6e39b90cc3e">bendDerivative</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The derivative of the bend function.  <a href="#e0abc5f931a45e7da829c6e39b90cc3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#afa4941f48c83147e99ffd38b69c85a7">gamma</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The gamma function.  <a href="#afa4941f48c83147e99ffd38b69c85a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#5f1ac55011fb534132e3e655a4ad85ef">logGamma</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns log(Gamma(x))  <a href="#5f1ac55011fb534132e3e655a4ad85ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#37c8942080d24a408651c5a81950efa1">logFactorial</a> (int x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns log(x!)  <a href="#37c8942080d24a408651c5a81950efa1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#de5314a017d76316e0ec272bf8d7e1c4">gaussian</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The gaussian function.  <a href="#de5314a017d76316e0ec272bf8d7e1c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#3bc17a1e5319ed986b1c520b53f26486">approximateErf</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an approximation for the error function of x.  <a href="#3bc17a1e5319ed986b1c520b53f26486"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#2d803ed9a78e2230f75eb6a0f5f70424">approximateInverseErf</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an approximation for the inverse of the error function.  <a href="#2d803ed9a78e2230f75eb6a0f5f70424"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#faee7cc597cc8ca9901a9fc2e0afecd9">productLog</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the y where x = y*exp(y). This is also known as the Omega function, or the Lambert W function. x must be &gt; -1/e.  <a href="#faee7cc597cc8ca9901a9fc2e0afecd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#9877b48122e2181817286b210f9e5c92">limboAdd</a> (double l, double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When l is somewhere between 0 and 1, it will do something in between "add" and "multiply" with a and b. When l is close to 0, this returns a value close to a + b. When l is close to 1, this returns a value close to a * b. When l is exactly 0 or 1, results are undefined, so you special-case those values to just call add or multiply.  <a href="#9877b48122e2181817286b210f9e5c92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#2fed64b90f62f6d2caba8a50724765f6">newtonPolynomial</a> (const double *pTValues, double *pFuncValues, int nPoints)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This implements Newton's method for determining a polynomial f(t) that goes through all the control points pFuncValues at pTValues. (You could then convert to a Bezier curve to get a Bezier curve that goes through those points.) The polynomial coefficients are put in pFuncValues in the form c0 + c1*t + c2*t*t + c3*t*t*t + ...  <a href="#2fed64b90f62f6d2caba8a50724765f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#5f26d50e47903d1affc84bfda768236e">integrate</a> (<a class="el" href="namespace_g_classes.html#e2576f1cef5c00b03a80fb750ce2f8ae">MathFunc</a> pFunc, double dStart, double dEnd, int nSteps, void *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integrates the specified function from dStart to dEnd.  <a href="#5f26d50e47903d1affc84bfda768236e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#462fd7cb06227be736126b7e274a0b6d">incompleteBeta</a> (double x, double a, double b, int steps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimates the Incomplete Beta function by "integrating" with the specified number of steps.  <a href="#462fd7cb06227be736126b7e274a0b6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#fcfaf8ddcc323a19aa6718d62b732c70">pascalsTriangle</a> (int *pOutRow, int nRow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the specified row from Pascal's triangle. pOutRow must be big enough to hold nRow + 1 elements Row 0 1 Row 1 1 1 Row 2 1 2 1 Row 3 1 3 3 1 Row 4 1 4 6 4 1 etc. such that each value is the sum of its two parents.  <a href="#fcfaf8ddcc323a19aa6718d62b732c70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#071edae8b484287721f9809718f11c33">nChooseK</a> (unsigned int n, unsigned int k)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value of n choose k.  <a href="#071edae8b484287721f9809718f11c33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#e19ea9621f599142d2ebb3ad0ff37404">tTestAlphaValue</a> (int v, double t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the p-value from the degrees of freedom, and the t-value obtained from a T-test.  <a href="#e19ea9621f599142d2ebb3ad0ff37404"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#823208e9dcc30fea84ea5b6f4ee75458">wilcoxonAlphaValue</a> (int n, double t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This computes the Wilcoxon alpha value assuming n is large enough that the Normal approximation will suffice.  <a href="#823208e9dcc30fea84ea5b6f4ee75458"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html#77df838454f70ebe9a878c8752f1e851">test</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs unit tests for this class. Throws an exception if there is a failure.  <a href="#77df838454f70ebe9a878c8752f1e851"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Provides some useful math functions. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3bc17a1e5319ed986b1c520b53f26486"></a><!-- doxytag: member="GClasses::GMath::approximateErf" ref="3bc17a1e5319ed986b1c520b53f26486" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::approximateErf           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an approximation for the error function of x. 
<p>

</div>
</div><p>
<a class="anchor" name="2d803ed9a78e2230f75eb6a0f5f70424"></a><!-- doxytag: member="GClasses::GMath::approximateInverseErf" ref="2d803ed9a78e2230f75eb6a0f5f70424" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::approximateInverseErf           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an approximation for the inverse of the error function. 
<p>

</div>
</div><p>
<a class="anchor" name="8bde82aae4a522d264eb51cebb06af2c"></a><!-- doxytag: member="GClasses::GMath::bend" ref="8bde82aae4a522d264eb51cebb06af2c" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::bend           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The bend function has a slope of 1 at very negative values of x, and 2 at very positive values of x, and a smooth transition in between. 
<p>

</div>
</div><p>
<a class="anchor" name="e0abc5f931a45e7da829c6e39b90cc3e"></a><!-- doxytag: member="GClasses::GMath::bendDerivative" ref="e0abc5f931a45e7da829c6e39b90cc3e" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::bendDerivative           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The derivative of the bend function. 
<p>

</div>
</div><p>
<a class="anchor" name="9589424fa4a4545c027c907d5c7fa9e0"></a><!-- doxytag: member="GClasses::GMath::bendInverse" ref="9589424fa4a4545c027c907d5c7fa9e0" args="(double y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::bendInverse           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The inverse of the bend function. 
<p>

</div>
</div><p>
<a class="anchor" name="afa4941f48c83147e99ffd38b69c85a7"></a><!-- doxytag: member="GClasses::GMath::gamma" ref="afa4941f48c83147e99ffd38b69c85a7" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::gamma           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The gamma function. 
<p>

</div>
</div><p>
<a class="anchor" name="de5314a017d76316e0ec272bf8d7e1c4"></a><!-- doxytag: member="GClasses::GMath::gaussian" ref="de5314a017d76316e0ec272bf8d7e1c4" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::gaussian           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The gaussian function. 
<p>

</div>
</div><p>
<a class="anchor" name="462fd7cb06227be736126b7e274a0b6d"></a><!-- doxytag: member="GClasses::GMath::incompleteBeta" ref="462fd7cb06227be736126b7e274a0b6d" args="(double x, double a, double b, int steps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::incompleteBeta           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>steps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Estimates the Incomplete Beta function by "integrating" with the specified number of steps. 
<p>

</div>
</div><p>
<a class="anchor" name="5f26d50e47903d1affc84bfda768236e"></a><!-- doxytag: member="GClasses::GMath::integrate" ref="5f26d50e47903d1affc84bfda768236e" args="(MathFunc pFunc, double dStart, double dEnd, int nSteps, void *pThis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::integrate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_g_classes.html#e2576f1cef5c00b03a80fb750ce2f8ae">MathFunc</a>&nbsp;</td>
          <td class="paramname"> <em>pFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pThis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Integrates the specified function from dStart to dEnd. 
<p>

</div>
</div><p>
<a class="anchor" name="91e805fbbee162296b31014d5e6b9954"></a><!-- doxytag: member="GClasses::GMath::interpolatingFunc" ref="91e805fbbee162296b31014d5e6b9954" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::interpolatingFunc           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A soft step function with a very high degree of continuity at 0 and 1. 
<p>

</div>
</div><p>
<a class="anchor" name="9877b48122e2181817286b210f9e5c92"></a><!-- doxytag: member="GClasses::GMath::limboAdd" ref="9877b48122e2181817286b210f9e5c92" args="(double l, double a, double b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::limboAdd           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When l is somewhere between 0 and 1, it will do something in between "add" and "multiply" with a and b. When l is close to 0, this returns a value close to a + b. When l is close to 1, this returns a value close to a * b. When l is exactly 0 or 1, results are undefined, so you special-case those values to just call add or multiply. 
<p>

</div>
</div><p>
<a class="anchor" name="37c8942080d24a408651c5a81950efa1"></a><!-- doxytag: member="GClasses::GMath::logFactorial" ref="37c8942080d24a408651c5a81950efa1" args="(int x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::logFactorial           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns log(x!) 
<p>

</div>
</div><p>
<a class="anchor" name="5f1ac55011fb534132e3e655a4ad85ef"></a><!-- doxytag: member="GClasses::GMath::logGamma" ref="5f1ac55011fb534132e3e655a4ad85ef" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::logGamma           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns log(Gamma(x)) 
<p>

</div>
</div><p>
<a class="anchor" name="44924e1ac8233faa08478d06fee9e75c"></a><!-- doxytag: member="GClasses::GMath::logistic" ref="44924e1ac8233faa08478d06fee9e75c" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::logistic           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The logistic sigmoid function. 
<p>

</div>
</div><p>
<a class="anchor" name="7a53cae14448fbd106574a5d5ff588a2"></a><!-- doxytag: member="GClasses::GMath::logisticDerivative" ref="7a53cae14448fbd106574a5d5ff588a2" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::logisticDerivative           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This evaluates the derivative of the sigmoid function. 
<p>

</div>
</div><p>
<a class="anchor" name="04534629d9a3aae25237dc634b539ff2"></a><!-- doxytag: member="GClasses::GMath::logisticInverse" ref="04534629d9a3aae25237dc634b539ff2" args="(double y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::logisticInverse           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the inverse of the logistic sigmoid function. 
<p>

</div>
</div><p>
<a class="anchor" name="071edae8b484287721f9809718f11c33"></a><!-- doxytag: member="GClasses::GMath::nChooseK" ref="071edae8b484287721f9809718f11c33" args="(unsigned int n, unsigned int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::nChooseK           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value of n choose k. 
<p>

</div>
</div><p>
<a class="anchor" name="2fed64b90f62f6d2caba8a50724765f6"></a><!-- doxytag: member="GClasses::GMath::newtonPolynomial" ref="2fed64b90f62f6d2caba8a50724765f6" args="(const double *pTValues, double *pFuncValues, int nPoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GMath::newtonPolynomial           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pTValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pFuncValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPoints</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This implements Newton's method for determining a polynomial f(t) that goes through all the control points pFuncValues at pTValues. (You could then convert to a Bezier curve to get a Bezier curve that goes through those points.) The polynomial coefficients are put in pFuncValues in the form c0 + c1*t + c2*t*t + c3*t*t*t + ... 
<p>

</div>
</div><p>
<a class="anchor" name="fcfaf8ddcc323a19aa6718d62b732c70"></a><!-- doxytag: member="GClasses::GMath::pascalsTriangle" ref="fcfaf8ddcc323a19aa6718d62b732c70" args="(int *pOutRow, int nRow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GMath::pascalsTriangle           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pOutRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nRow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the specified row from Pascal's triangle. pOutRow must be big enough to hold nRow + 1 elements Row 0 1 Row 1 1 1 Row 2 1 2 1 Row 3 1 3 3 1 Row 4 1 4 6 4 1 etc. such that each value is the sum of its two parents. 
<p>

</div>
</div><p>
<a class="anchor" name="faee7cc597cc8ca9901a9fc2e0afecd9"></a><!-- doxytag: member="GClasses::GMath::productLog" ref="faee7cc597cc8ca9901a9fc2e0afecd9" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::productLog           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the y where x = y*exp(y). This is also known as the Omega function, or the Lambert W function. x must be &gt; -1/e. 
<p>

</div>
</div><p>
<a class="anchor" name="9bc4d4e675d993c54b2bb0a2d44f6000"></a><!-- doxytag: member="GClasses::GMath::signedRoot" ref="9bc4d4e675d993c54b2bb0a2d44f6000" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::signedRoot           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns sign(x) * sqrt(ABS(x)). 
<p>

</div>
</div><p>
<a class="anchor" name="0721e5f9c20e75e3ca0380f79c1d5a57"></a><!-- doxytag: member="GClasses::GMath::softStep" ref="0721e5f9c20e75e3ca0380f79c1d5a57" args="(double x, double steepness)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::softStep           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>steepness</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates a function that always passes through (0, 0), (1, 1), and (0.5, 0.5). The slope at (0.5, 0.5) will be "steepness". If steepness is &gt; 1, then the slope at (0, 0) and (1, 1) will be 0. If steepness is &lt; 1, the slope at (0, 0) and (1, 1) will be infinity. If steepness is exactly 1, the slope will be 1 at those points. softStep(1/x, 2) = PI*cauchy(x-1). 
<p>

</div>
</div><p>
<a class="anchor" name="77df838454f70ebe9a878c8752f1e851"></a><!-- doxytag: member="GClasses::GMath::test" ref="77df838454f70ebe9a878c8752f1e851" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GMath::test           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs unit tests for this class. Throws an exception if there is a failure. 
<p>

</div>
</div><p>
<a class="anchor" name="e19ea9621f599142d2ebb3ad0ff37404"></a><!-- doxytag: member="GClasses::GMath::tTestAlphaValue" ref="e19ea9621f599142d2ebb3ad0ff37404" args="(int v, double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::tTestAlphaValue           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the p-value from the degrees of freedom, and the t-value obtained from a T-test. 
<p>

</div>
</div><p>
<a class="anchor" name="823208e9dcc30fea84ea5b6f4ee75458"></a><!-- doxytag: member="GClasses::GMath::wilcoxonAlphaValue" ref="823208e9dcc30fea84ea5b6f4ee75458" args="(int n, double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMath::wilcoxonAlphaValue           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This computes the Wilcoxon alpha value assuming n is large enough that the Normal approximation will suffice. 
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Nov 2 14:18:24 2010 for GClasses by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
