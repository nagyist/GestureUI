<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>GClasses: GClasses::GManifold Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_g_classes.html">GClasses</a>::<a class="el" href="class_g_classes_1_1_g_manifold.html">GManifold</a>
  </div>
</div>
<div class="contents">
<h1>GClasses::GManifold Class Reference</h1><!-- doxytag: class="GClasses::GManifold" -->This class stores static methods that are useful for manifold learning.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;GManifold.h&gt;</code>
<p>

<p>
<a href="class_g_classes_1_1_g_manifold-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold.html#c9c26ee6acea93c0a1eff227c1422e1c">computeNeighborWeights</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pData, size_t point, int k, const size_t *pNeighbors, double *pOutWeights)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a set of weights for each neighbor to linearly approximate this point.  <a href="#c9c26ee6acea93c0a1eff227c1422e1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold.html#748911f7fb9548a2f0c76067a3e34b65">blendNeighborhoods</a> (size_t index, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pA, double ratio, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pB, int neighborCount, size_t *pHood)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Aligns and averages two local neighborhoods together. The results will be centered around the neighborhood mean. The first point will be the index point, and the rest will be neighborhood points with an index that is not INVALID_INDEX.  <a href="#748911f7fb9548a2f0c76067a3e34b65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold.html#aba59790ba8f19cc1cea3192f7efe77e">blendEmbeddings</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pA, double *pRatios, <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pB, int neighborCount, size_t *pNeighborTable, size_t seed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines two embeddings to form an "average" embedding. pRatios is an array that specifies how much to weight the neighborhoods around each point. If the ratio for a point is close to zero, pA will be emphasized more. If the ratio for the point is close to 1, pB will be emphasized more. "seed" specifies a starting point. It will blend outward in a breadth-first manner.  <a href="#aba59790ba8f19cc1cea3192f7efe77e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold.html#c618ab4b25022336ba6eccacf9f9ada1">multiDimensionalScaling</a> (<a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *pDistances, int targetDims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand, bool useSquaredDistances)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs classic MDS. pDistances must be a square matrix, but only the upper-triangle is used. Each row in the results is one of the result points. If useSquaredDistances is true, then the values in pDistances are assumed to be squared distances, rather than normal Euclidean distances.  <a href="#c618ab4b25022336ba6eccacf9f9ada1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold.html#f4b6feed288c0bfd805d7d743bdd22d2">test</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class stores static methods that are useful for manifold learning. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="aba59790ba8f19cc1cea3192f7efe77e"></a><!-- doxytag: member="GClasses::GManifold::blendEmbeddings" ref="aba59790ba8f19cc1cea3192f7efe77e" args="(GData *pA, double *pRatios, GData *pB, int neighborCount, size_t *pNeighborTable, size_t seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GManifold::blendEmbeddings           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pRatios</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>neighborCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>pNeighborTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>seed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Combines two embeddings to form an "average" embedding. pRatios is an array that specifies how much to weight the neighborhoods around each point. If the ratio for a point is close to zero, pA will be emphasized more. If the ratio for the point is close to 1, pB will be emphasized more. "seed" specifies a starting point. It will blend outward in a breadth-first manner. 
<p>

</div>
</div><p>
<a class="anchor" name="748911f7fb9548a2f0c76067a3e34b65"></a><!-- doxytag: member="GClasses::GManifold::blendNeighborhoods" ref="748911f7fb9548a2f0c76067a3e34b65" args="(size_t index, GData *pA, double ratio, GData *pB, int neighborCount, size_t *pHood)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GManifold::blendNeighborhoods           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>neighborCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>pHood</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Aligns and averages two local neighborhoods together. The results will be centered around the neighborhood mean. The first point will be the index point, and the rest will be neighborhood points with an index that is not INVALID_INDEX. 
<p>

</div>
</div><p>
<a class="anchor" name="c9c26ee6acea93c0a1eff227c1422e1c"></a><!-- doxytag: member="GClasses::GManifold::computeNeighborWeights" ref="c9c26ee6acea93c0a1eff227c1422e1c" args="(GData *pData, size_t point, int k, const size_t *pNeighbors, double *pOutWeights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GManifold::computeNeighborWeights           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&nbsp;</td>
          <td class="paramname"> <em>pNeighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pOutWeights</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes a set of weights for each neighbor to linearly approximate this point. 
<p>

</div>
</div><p>
<a class="anchor" name="c618ab4b25022336ba6eccacf9f9ada1"></a><!-- doxytag: member="GClasses::GManifold::multiDimensionalScaling" ref="c618ab4b25022336ba6eccacf9f9ada1" args="(GData *pDistances, int targetDims, GRand *pRand, bool useSquaredDistances)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_data.html">GData</a>* GClasses::GManifold::multiDimensionalScaling           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_data.html">GData</a> *&nbsp;</td>
          <td class="paramname"> <em>pDistances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>targetDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&nbsp;</td>
          <td class="paramname"> <em>pRand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useSquaredDistances</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs classic MDS. pDistances must be a square matrix, but only the upper-triangle is used. Each row in the results is one of the result points. If useSquaredDistances is true, then the values in pDistances are assumed to be squared distances, rather than normal Euclidean distances. 
<p>

</div>
</div><p>
<a class="anchor" name="f4b6feed288c0bfd805d7d743bdd22d2"></a><!-- doxytag: member="GClasses::GManifold::test" ref="f4b6feed288c0bfd805d7d743bdd22d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GManifold::test           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Nov 2 14:18:24 2010 for GClasses by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
